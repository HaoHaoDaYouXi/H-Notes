# Redis概述

- `Redis`是一个开源的使用`ANSI C`语言编写、支持网络、可基于内存亦可持久化的日志型、`Key-Value`（键值型）数据库（非关系型数据库），并提供多种语言的`API`。

- `Redis`是一个高性能的`Key-Value`数据库。它的出现很大程度补偿来`MemCached`这类`Key-Value`型存储的不足，在部分场合下可以对关系型数据库起到很好的补充作用。它提供来`Java`、`C/C++`、`PHP`、`JavaScript`、`Perl`、`Object-C`、`Python`、`Ruby`、`Erlang`等客户端，使用方便。

- `Redis`支持主从同步，`Redis`能够借助于`Sentinel`（哨兵，`Redis`自带的）工具来监控主从节点，当主节点发生故障时，会自己提升另外一个从节点成为新的主节点。

## <a id="sjlx">数据类型</a>

### String（字符串）

字符串类型实际上是动态字符串（Simple Dynamic String，SDS）

`SDS`数据结构
- `len`：表示已使用的字符长度。
- `alloc`：表示分配的内存大小。
- `buf`：实际存储字符的数组。

优点
- 获取字符串长度的时间复杂度为`O(1)`：因为长度是保存在结构中的，不需要遍历整个字符串。
- 惰性空间释放：在缩短字符串时，并不会立即缩小内存，而是保留以备后用，减少了频繁的内存分配和释放。
- 预分配：在扩展字符串时，按一定策略多分配一些内存，减少了内存分配的次数。

操作命令
- `SET key value`：设置`key`的值。如果`key`存在，覆盖。
- `GET key`：获取`key`的值。
- `INCR key`：将`key`的值加`1`。如果`key`不存在，初始化为`0`后再加`1`。
- `DECR key`：将`key`的值减`1`。如果`key`不存在，初始化为`0`后再减`1`。
- `APPEND key value`：将`value`追加到指定`key`的值之后。如果`key`不存在，则创建一个新的`key`。
- `STRLEN key`：获取`key`的值的长度。
- `MSET key value [key value ...]`：同时设置多个`key-value`对。
- `MGET key [key ...]`：同时获取多个`key`的值。
- `GETSET key value`：设置新的值并返回旧的值。

使用场景
- 缓存数据：常用于缓存数据，如：缓存数据，减少数据库交互，提高性能。
- 分布式锁：通过`SETNX`命令可以实现分布式锁。
- 计数器：例如记录访问量，通过`INCR`和`DECR`命令实现。

### List（列表）

列表是一种有序的数据结构，允许在头部和尾部进行插入和删除操作。
列表中的每个元素都是一个字符串，并且可以通过索引下标进行访问。
列表底层是双向链表，当元素较少时，会用压缩列表来实现。

数据结构
- 压缩列表（`ziplist`）：当列表中的元素较少且每个元素长度较短时，`Redis`使用压缩列表实现。这是一种连续内存块，内存占用较少，但在执行插入和删除操作时需要移动大量数据。
- 双向链表（`linkedlist`）：当列表中的元素较多或元素较大时，`Redis`使用双向链表实现。双向链表的优点是插入和删除操作的时间复杂度为`O(1)`，但每个节点都需要额外的内存来存储前驱和后继指针。

操作命令
- `LPUSH key value`：将`value`插入到列表的左端。
- `RPUSH key value`：将`value`插入到列表的右端。
- `LPOP key`：移除并返回列表的左端元素。
- `RPOP key`：移除并返回列表的右端元素。
- `LRANGE key start stop`：获取列表中指定范围内的元素。范围从`start`到`stop`，包括`start`和`stop`。
- `LINDEX key index`：通过索引获取列表中的元素，索引从`0`开始。
- `LSET key index value`：通过索引设置列表中元素的值。
- `LLEN key`：获取列表的长度。
- `LINSERT key BEFORE|AFTER pivot value`：在列表中指定的值前或后插入新值。

使用场景
- 消息队列：通过`LPUSH`和`RPOP`命令实现，生产者将消息放入队列左端，消费者从右端取出消息。
- 任务队列：存储待处理的任务，通过`BRPOP`实现阻塞队列，等待任务的到来。
- 最近访问记录：例如浏览历史，最新访问的内容总是插入到列表头部。

### Sets（集合）

集合是一种无序且不重复的字符串集合。集合底层基于哈希表，当元素较少时会使用整数数组。

数据结构
- 整数集合（`intset`）：当集合中的元素都是整数且数量较少时，使用整数集合实现。整数集合是一种紧凑的数据结构，内存占用少，但只支持整数类型。
- 哈希表（`hashtable`）：当集合中的元素较多或包含非整数类型时，使用哈希表实现。哈希表的查找、插入和删除操作时间复杂度为`O(1)`，但每个元素需要额外的内存来存储哈希值和指针。

操作命令
- `SADD key member`：向集合添加一个元素。如果元素已存在，则忽略该操作。
- `SREM key member`：移除集合中的一个元素。如果元素不存在，则忽略该操作。
- `SMEMBERS key`：返回集合中的所有元素。
- `SISMEMBER key member`：判断`member`是否是集合中的元素。
- `SUNION key [key ...]`：返回给定所有集合的并集。
- `SINTER key [key ...]`：返回给定所有集合的交集。
- `SDIFF key [key ...]`：返回第一个集合与其他集合的差集。
- `SCARD key`：获取集合的元素数量。

使用场景
- 标签管理：例如给文章添加标签，一个标签集合对应一个文章。
- 好友关系：存储用户的好友列表，通过集合的交集操作可以找到共同好友。
- 去重操作：如：存访问`IP`，通过集合的无重复特性实现去重。

### Sorted Sets（有序集合）

有序集合类似于集合，但每个元素都会关联一个分数（`score`），`Redis`会按分数值进行排序。
分数可以是任意双精度浮点数。与集合不同，有序集合中的元素是有序的。
有序集合的底层实现是跳跃表（`skiplist`）和哈希表（`hashtable`）的结合。

数据结构
- 跳跃表（`skiplist`）：跳跃表是一种以层级结构实现的有序数据结构，支持高效的范围查询和按分数排序。跳跃表由多个层级构成，每一层是一个有序链表，底层链表包含所有元素，每高一层的链表是低层链表的一个子集。跳跃表的查找、插入和删除操作的平均时间复杂度为`O(log N)`。
- 哈希表（`hashtable`）：哈希表用于快速查找元素和分数，支持`O(1)`时间复杂度的插入、删除和查找操作。

这种结构让有序集合具备高效的范围查询和排序能力，能快速进行元素查找和更新操作。

操作命令
- `ZADD key score member`：向有序集合添加元素，并设置其分数。如果元素已存在，则更新其分数。
- `ZREM key member`：移除有序集合中的一个元素。
- `ZRANGE key start stop [WITHSCORES]`：返回指定范围内的元素（按分数从低到高排序）。
- `ZREVRANGE key start stop [WITHSCORES]`：返回指定范围内的元素（按分数从高到低排序）。
- `ZRANK key member`：返回元素的排名（按分数从低到高）。
- `ZREVRANK key member`：返回元素的排名（按分数从高到低）。
- `ZSCORE key member`：返回元素的分数。
- `ZINTERSTORE destination numkeys key [key ...]`：计算给定有序集合的交集，并存储在新的有序集合中。
- `ZUNIONSTORE destination numkeys key [key ...]`：计算给定有序集合的并集，并存储在新的有序集合中。

使用场景
- 排行榜：例如积分排行榜，通过分数进行排序，实时更新排名。
- 优先级队列：通过分数表示优先级，分数越低优先级越高。
- 延迟队列：通过分数表示延迟时间，分数越低延迟越短。

### Hash（哈希类型、关联数组）

哈希是一种键值对集合，每个键对应一个哈希表，哈希表内部包含多个字段和对应的值，适用于存储对象数据。
哈希类型的数据结构类似于传统的字典或映射表，特别适合表示对象（例如用户信息、商品信息等）。

数据结构
- 压缩列表（`ziplist`）：当哈希表中的字段较少且字段和值长度较短时，使用压缩列表实现。压缩列表是一种连续内存块，内存占用较少，但在执行插入和删除操作时需要移动大量数据。
- 哈希表（`hashtable`）：当哈希表中的字段较多或字段和值较长时，使用哈希表实现。哈希表的查找、插入和删除操作时间复杂度为`O(1)`，但每个字段和值需要额外的内存来存储哈希值和指针。

操作命令
- `HSET key field value`：设置哈希表中指定字段的值。如果字段不存在，则创建。
- `HGET key field`：获取哈希表中指定字段的值。
- `HDEL key field [field ...]`：删除哈希表中指定字段。
- `HGETALL key`：获取哈希表中所有字段和值。
- `HKEYS key`：获取哈希表中的所有字段。
- `HVALS key`：获取哈希表中的所有值。
- `HLEN key`：获取哈希表中的字段数量。
- `HEXISTS key field`：判断哈希表中是否存在指定字段。
- `HMSET key field value [field value ...]`：同时设置哈希表中多个字段的值。
- `HMGET key field [field ...]`：同时获取哈希表中多个字段的值。

使用场景
- 存储信息：例如用户信息、商品信息等，通过哈希表存储。
- 会话信息：存储会话状态和数据。

### Bitmaps（位图）

位图是一种紧凑的方式来存储二进制数据，可以将其视为一个位数组。
每个位可以存储`0`或`1`，用于表示布尔值。
位图通常用于记录状态信息，如用户签到、活动参与情况等。

数据结构
- 位图是基于字符串实现的，字符串的每个字节由`8`个比特位构成，可以表示`8`个布尔值。位图操作实际上是对字符串进行位操作。

操作命令
- `SETBIT key offset value`：将位图中指定偏移量的位设置为`0`或`1`。
- `GETBIT key offset`：获取位图中指定偏移量的位的值。
- `BITCOUNT key [start end]`：统计位图中值为`1`的位的数量。
- `BITOP operation destkey key [key ...]`：对一个或多个位图进行按位操作，并将结果存储在新的位图中。操作包括`AND`、`OR`、`NOT`、`XOR`。

使用场景
- 用户签到：记录用户每天的签到情况，一个位代表一天。
- 活动参与：记录用户是否参与活动。
- 权限管理：记录权限位，一个位代表一种权限。

### HyperLoglog

`HyperLogLog`是一种用于基数统计的概率算法，适用于需要统计大量数据的场景，如独立`IP`访问量、用户数等。
它的优势在于占用内存非常小，但能够在一定误差范围内提供准确的基数估计。

数据结构
- `HyperLogLog`的数据结构基于概率算法，通过哈希函数将数据映射到不同的桶，并记录桶中的最大值。它使用少量内存（通常`12KB`）来存储基数估计信息。

操作命令
- `PFADD key element [element ...]`：将元素添加到`HyperLogLog`中。
- `PFCOUNT key [key ...]`：返回`HyperLogLog`中独立元素的估计数量。
- `PFMERGE destkey sourcekey [sourcekey ...]`：合并多个`HyperLogLog`并将结果存储在新的`HyperLogLog`中。

使用场景
- 独立访客统计：统计网站独立访客数量。
- 用户行为分析：统计不同用户的行为次数，如点击、点赞等。

### Geo（地理空间）

`Geo`可以存储地理位置数据，并提供基于位置的操作命令，如附近位置查询、距离计算等。

数据结构
- 地理空间数据类型基于有序集合（`Sorted Set`）实现。每个成员的分数是通过`Geohash`算法计算得到的，使得地理位置可以通过有序集合进行存储和排序。

操作命令
- `GEOADD key longitude latitude member`：将地理位置添加到地理空间集合中。
- `GEOPOS key member [member ...]`：获取地理空间集合中成员的位置（经度和纬度）。
- `GEODIST key member1 member2 [unit]`：计算两个成员之间的距离，单位可以是`m（米）`、`km（千米）`、`mi（英里`）、`ft（英尺）`。
- `GEORADIUS key longitude latitude radius m|km|mi|ft`：以给定的经纬度为中心，查询指定半径范围内的所有成员。
- `GEORADIUSBYMEMBER key member radius m|km|mi|ft`：以给定的成员为中心，查询指定半径范围内的所有其他成员。

使用场景
- 附近地点查询：例如餐厅、商店、加油站等。
- 用户位置服务：提供基于位置的服务，如打车、外卖等。

## <a id="xn">性能</a>

- `100万`较小的键存储字符串，大概消耗`100M`内存；

- `Redis`是单线程，如果服务器主机上有多个`CPU`，只有一个能够使用，但并不意味着`CPU`会成为瓶颈，因为`Redis`是一个比较简单的`K-V`数据存储，`CPU`不会成为瓶颈的

- 在常见的`linux`服务器上，`500K`（`50万`）的并发，只需要`一秒`处理，如果主机硬件较好的情况下，每秒钟可以达到上百万的并发

## <a id="redismemcache">Redis与MemCache</a>

- `MemCache`只能使用内存来缓存对象。而`Redis`除了可以使用内存来缓存对像，还可以周期性的将数据保存到磁盘上，对数据进行永久存储。当服务器突然断电或死机后，`Redis`基于磁盘中的数据进行恢复

- `Redis`是单线程服务器，只有一个线程来响应所有的请求。`MemCache`是多线程的

- `Redis`支持更多的数据类型

## <a id="cjh">持久化</a>

`Redis`提供了多种级别的持久化方式：
- `RDB`持久化可以在指定时间间隔生成数据的时间快照(`point-in-time snapshot`)。
- `AOF`持久化记录服务器所有的写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据，`AOF`文件中的命令全部以`Redis`协议的格式保存，新命令追加到文件的末尾，
  `Redis`还可以在后台对`AOF`文件重写，保证`AOF`文件大小不超过保存数据状态的实际大小	

### RDB

`RDB`触发可以分两种手动触发和自动触发，手动触发对应`save`和`bgsave`命令

`save`阻塞当前`redis`服务器，直到`RDB`完成，对内存大的实例会造成长时间的阻塞，线上不建议使用

`bgsave`：`Redis`进程执行`fork`操作创建子线程，由子线程负责，完成后自动结束，阻塞只会在`fork`时，一般很短

自动触发通过配置`save`，如`save m n`，表示`m秒`内数据集存在`n次`修改时，
自动触发`bgsave`, 节点执行全量复制操作，主节点自动执行`bgsave`生成`RDB`文件并发送给从节点，

执行`debug reload`命令重新加载`Redis`时，也会自动触发`save`操作，
默认情况下执行`shutdown`命令时，如果没有开启`AOF`持久化则自动执行`bgsave`，`bgsave`是`RDB`主流的持久化方式，

执行`bgsave`命令时，`Redis`父进程判断是否存在正在执行的`RDB`、`AOF`子进程，有就直接返回，没有就`fork`操作创建一个子线程，`fork`过程中父进程会阻塞，

通过`info stats`可以查看`latest_fork_usec`选项，可以返回一个最近`fork`操作的耗时，单位微秒，`fork`完后，
`bgsave`返回`background saving started`不在阻塞父进程，可以继续其他命令，子线程创建`RDB`文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换，
通过`lastsave`命令可以查看最后一次生成`RDB`时间，子线程完成后告诉父线程，父线程更新信息，`RDB`文件保存在`dir`配置指定的目录下

优点

它是一个二进制的文件，代表`Redis`在某个时间节点上的数据快照，非常适合备份，全量复制，比如每`6小时`执行`bgsave`备份，
并把`RDB`文件拷贝到远程机器或文件系统，用于灾难恢复，`Redis`加载`RDB`恢复数据远远快于`AOF`方式

缺点

没办法做到实时/秒级持久化，因为每次`bgsave`都要执行`fork`创建子线程，属于重量级操作，频繁操作成本太高，
`RDB`文件使用特定的二进制保存，`Redis`老版本无法兼容新版本

### `AOF`

开启`AOF`需要设置配置：`appendonly yes`，默认不开启，`AOF`文件保存路径也是通过`dir`配置

`AOF`流程是：命令写入(`append`)、文件同步(`sync`)、文件重写(`rewrite`)、重启加载(`load`)

`AOF`所有的写入命令会追加到`aof_buf`(缓冲区)，`Redis`使用单线程响应命令，如果每次写`AOF`文件命令都追加到硬盘，那性能全部取决于硬盘的负债

`Redis`可以提供多种缓冲区同步硬盘的策略，在性能和安全做出平衡，根据`AOF`的文件越来越大，需要定期重写`AOF`文件，达到压缩，
重写就是把已经超时的数据不在写入，还有各种数据定义和改变过程，只保留最终的值，多个写入的命令也可以合并一个，
重写不止减少空间，也是为了`Redis`更快的重载，

重写过程可以手动触发和自动触发

- 手动触发直接调用`bgrewriteaof`命令，自动触发根据设置的参数(`auto-aof-rewrite-min-size`
  最小大小 默认`64M`，`auto-aof-rewrite-percentage`当前文件空间(`aof_current_size`)和上次重写AOF文件空间(`aof_base_size`)的比值)
- 自动触发机制：当前文件大小大于最小体积 && (当前大小-上次重写大小) / 上次重写大小 >= 规定的比值

`Redis`重启时，若开启`AOF`持久化并存在`AOF`文件，优先加载`AOF`文件，`AOF`关闭或文件不存在，加载`RDB`，加载文件成功后，
`Redis`启动成功，文件存在错误，启动失败并打印错误信息

## <a id="gky">高可用</a>

`Redis`的几种常见使用方式包括
- 单副本
- 多副本（主从）
- `Sentinel`（哨兵）
- `Cluster`
- 自研

### 主从复制

`Redis`主从复制主要分两个角色，主机(`master`)主要负责读写操作，从机(`slave`)主要负责读操作，主机定期同步数据到从机上，保证数据一致性。

`Redis`同步数据主要分两种，全量同步和增量同步。

主从复制不会阻塞`master`，在同步数据时，`master`还可以继续处理请求，`Redis`会生成新的进程来解决同步问题。

主从里面的从也可以是主(树形结构)，提高效率，减少主机压力。
主机可以有多个从机，从机只能有一个主机。

主从配置一般是修改`redis.conf`文件内的`slaveof`格式：`slaveof ip port`，

`redis-cli -p 6379 info Replication`：可以查看主机有几个从机。

### 同步数据

主要分全量同步和增量同步

从机第一次链接一定是全量同步，短线重连根据`runid`判断是否一致来执行全量同步或增量同步，
每个redis服务器都有自己的`runid`，主机根据`runid`查询有没有保存，

没有就全量同步，有就增量同步，

主从服务器会分别维护一个`offset`(复制偏移量)主机每次向服务器传播`N`个字节的数据时，
就会把自己的`offset`的值加`N`，从机每次接受到`N`个字节数据时，就将自己的`offset`加`N`。

复制积压缓冲区是主机维护的一个固定长度的先进先出的队列，默认大小`1M`，
主要是当主机传播命令时，把命令放入，当断开时，
主机会将缓冲区的所有数据发给从机(断开之后的数据)。

同步执行过程，从机链接时判断自己是否保存了主机的`runid`(判断是否第一次)，
没有保存就向主机发出全量同步，有保存就把`runid`发送给主机，主机判断是否和自己的一致，
不一致就把当前的`runid`在发给从机并执行全量同步，一致就会判断`offset`相差有没有超过缓冲区的大小，

没有就等待主机同步数据给从机，超过主机就生成快照文件，给从机在同步缓冲区的数据。

全量同步分三个流程：

- 同步快照(主机创建并发送快照给从机，从机进入快照并解析，主机同时将此阶段生成的新命令写入到缓冲区)，
- 同步缓冲区(主机向从机同步缓冲区的写的操作命令)，
- 同步增量(主机同步写操作到从机)

增量同步主要在从机完成初始化正常工作时，主机发生写操作就同步到从机，
正常主机每执行一个写命令就向从机发请求，从机接受并处理。

### 哨兵(`sentinel`)机制

`sentinel`主要监控`Redis`集群中`master`的状态，当`master`发生故障时，可以实现`master`和`slave`的切换，保证系统的高可用。

主从的缺点，没法对`master`进行动态选举，这需要`sentinel`机制完成。
`sentinel`会不断检查`master`和`slave`状态是否正常，当发现某个节点出问题时，
`sentinel`可以通过`API`向管理员或其他应用程序发送通知。

当`master`不能正常操作时，`sentinel`会开始一次故障转移，会将失效的`master`下的一个`slave`升级为新的`master`，
并让其他`slave`改为新的`master`，当客户端试图链接失效的`master`，集群会向客户端展示新的`master`地址，切换后对应的配置文件都会有所变化，
`master`会对一个`slaveof`的配置，`slave`对应的`master`也改成新的，`sentinel.conf`的监控对象也会改变。

#### sentinel 故障判断原理

每个`sentinel`进程每秒钟一次的频率向整个集群中的`master`、`slave`以及其他的`sentinel`进程发送一个`ping`的请求

如果一个实例距离最后一次有效`ping`请求超过`down-after-milliseconds`规定的值，这个实例就会被`sentinel`标记为主观下线(`SDOWN`)

如果一个`master`被标记为主观下线，则正在监视这个`master`的`sentinel`进程要以`每秒一次`的频率确定`master`的确进入`主观下线状态`

当超过配置文件中给定的`sentinel`的数量，在指点的时间范围内确定`master`进入了`主观下线状态`，则`master`会被标记为客观下线(`ODOWN`)

一般情况每个`sentinel`会以每`10s一次`的频率向集群中所有的`master`、`slave`发送`info`命令，
当`master`被标记为`客观下线`，`sentinel`会向下面所有的`slave`发送`info`的频率改为`1s一次`

若没有一定数量的`sentinel`同意`master`下线，那`master`的客观下线状态会被移除

若`master`对`ping`的命令有回复，`master`的主观下线状态也会被移除

## <a id="bfwt">Redis雪崩、穿透、并发等问题</a>

在高并发中，`Redis`会出现雪崩、穿透、并发等问题，其实大体就是：数据一致性和缓存访问不到的问题

### 雪崩

问题描述：

大量缓存数据在同一时间失效或`Redis`出现问题，导致缓存不能命中，直接访问数据库，承受巨大压力

解决方案：

- 分散缓存过期时间：避免所有缓存同时失效，可以通过为不同的缓存项设置随机的过期时间来实现。
- 缓存预热：在系统启动或预计有高峰流量前，预先加载热点数据到缓存中。
- 降级策略：当缓存失效且数据库负载过高时，可以暂时返回缓存中的旧数据或者默认值，直到缓存更新完成。
- 使用后备存储：如断路器，以保护后端服务免受突发流量的影响。

### 穿透

问题描述： 

如果查询的数据在缓存和数据库中都不存在，每次请求都会直接打到数据库上

解决方案：

- 空值缓存：将查询结果为空的情况也进行缓存，通常设置较短的过期时间。
- 布隆过滤器：用于判断一个元素是否在一个集合中，可以快速过滤掉大部分不存在的查询，减少数据库的无效访问。

### 击穿

问题描述： 

Redis击穿（也称为热点key击穿）指的是某个非常热门的key在其缓存失效的瞬间，大量的并发请求直接打到后端数据库上，造成数据库压力骤增，甚至可能导致数据库宕机。
这种情况通常发生在热点数据的缓存失效时，因为这些数据被频繁访问，一旦缓存失效，所有请求会立即转向数据库。

解决方案：

- 互斥锁（Mutex）：在缓存失效时，使用分布式锁（如Redis的SETNX或SET命令的NX选项）来控制只允许一个请求去加载数据并更新缓存，其他请求则等待锁释放后再尝试获取数据。这样可以避免所有请求同时访问数据库。
  ```
  if (redis.get(key) == null) {
     // 尝试获取锁
     if (redis.setnx(lockKey, lockValue)) {
         try {
             // 锁获取成功，执行数据库操作并更新缓存
             Object value = dbOperation();
             redis.set(key, value);
         } finally {
             // 释放锁
             redis.del(lockKey);
         }
     } else {
         // 锁获取失败，等待并重试
         Thread.sleep(someTime);
         retry();
     }
  }
  ```
- 缓存预热：在系统启动或预测到高峰流量到来之前，提前加载热点数据到缓存中，避免在高峰期因缓存失效而引发击穿。
- 二级缓存：在主缓存失效后，可以先从二级缓存（如内存中的Map或其他缓存系统）中获取数据，同时异步更新主缓存，这样可以减轻数据库的压力。
- 限流：对数据库的访问进行限流，可以使用漏桶算法或令牌桶算法来控制单位时间内到达数据库的请求量，避免瞬时大量请求冲击数据库。
- 超时时间随机化：对于热点数据，可以设置一个较长的缓存超时时间，并在此基础上增加一定的随机延时，避免所有请求在同一时间点失效。

### 并发

问题描述：

多个客户端同时对同一个键进行读写操作，可能导致数据不一致或丢失。

解决方案：

- 乐观锁/悲观锁：在更新缓存时使用锁机制，如`WATCH`命令或外部锁服务，确保数据的一致性。
- 队列机制：将并发的写操作放入队列，按顺序执行，避免同时写入冲突。
- 原子操作：利用`Redis`的原子命令如`INCR`，`DECR`，`GETSET`等，这些命令可以在不使用锁的情况下保证操作的原子性。



----
