# Zookeeper
`Zookeeper`是一个分布式协调服务，可用于服务发现，分布式锁，分布式领导选举，配置管理等。

`Zookeeper`提供了一个类似于`Linux`文件系统的树形结构
（可认为是轻量级的内存文件系统，但只适合存少量信息，完全不适合存储大量文件或者大文件），
同时提供了对于每个节点的监控与通知机制。

据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。

**分布式应用程序可以基于`Zookeeper`实现**
- 数据发布/订阅
- 负载均衡
- 命名服务
- 分布式协调/通知
- 集群管理
- `Master`选举
- 分布式锁和分布式队列
- 等

**`Zookeeper`保证了如下分布式一致性特性：**
- 顺序一致性
- 原子性
- 单一视图
- 可靠性
- 实时性（最终一致性）

客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的`zookeeper`机器来处理。
对于写请求，这些请求会同时发给其他`zookeeper`机器并且达成一致后，请求才会返回成功。
因此，随着`zookeeper`的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。

有序性是`zookeeper`中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，
这个时间戳称为`zxid`（Zookeeper Transaction Id）。
而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个`zookeeper`最新的`zxid`。

## Zookeeper 文件系统
`Zookeeper`提供一个多层级的节点命名空间（节点称为`znode`）。与文件系统不同的是，这些节点都可
以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。
`Zookeeper`为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得`Zookeeper`
不能用于存放大量的数据，每个节点的存放数据上限为`1M`。

## Zookeeper 通知机制
`Zookeeper`允许客户端对服务端的某个`znode`注册一个`watcher`监听事件，当服务端的一些指定事件触发了这个`watcher`，
服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据`watcher`通知状态和事件类型做出业务上的改变。

**大致分为三个步骤：**

- 客户端注册`watcher`
  - 调用`getData`、`getChildren`、`exist`三个API ，传入`watcher`对象。 
  - 标记请求`request`，封装`watcher`到`WatchRegistration`。 
  - 封装成`Packet`对象，发服务端发送`request`。 
  - 收到服务端响应后，将`watcher`注册到`ZKWatcherManager`中进行管理。
  - 请求返回，完成注册。
- 服务端处理`watcher`
  - 服务端接收`watcher`并存储
  - `watcher`触发，调用`process`方法来触发`watcher`。
- 客户端回调`watcher`
  - 客户端`SendThread`线程接收事件通知，交由`EventThread`线程回调`watcher`。 
  - 客户端的`watcher`机制同样是一次性的，一旦被触发后，该`watcher`就失效了。

**总结**：客户端会对某个`znode`建立一个`watcher`事件，当该`znode`发生变化时，
这些客户端会收到`Zookeeper`的通知，然后客户端可以根据`znode`变化来做出业务上的改变等。

### Zookeeper 通知机制的特点

- 一次性触发数据发生改变时，一个`watcher event`会被发送到客户端，但是客户端只会收到一次这样的信息。
- `watcher event`异步发送`watcher`的通知事件从服务端发送到客户端是异步的，这就存在一个问题，
  - 不同的客户端和服务器之间通过`socket`进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，
  - 由于`Zookeeper`本身提供了`ordering guarantee`，即客户端监听事件后，才会感知它所监视`znode`发生了变化。
  - 所以我们使用`Zookeeper`不能期望能够监控到节点每次的变化。
  - `Zookeeper`只能保证最终的一致性，而无法保证强一致性。
- 数据监视`Zookeeper`有数据监视和子数据监视`getData()`、`exists()`设置数据监视，`getchildren()`设置了子节点监视。
- 注册`watcher`，`getData`、`exists`、`getChildren`
- 触发`watcher`，`create`、`delete`、`setData`
- `setData()`会触发`znode`上设置的`data watch`（如果`set`成功的话）。
  - 一个成功的`create()`操作会触发被创建的`znode`上的数据`watch`，以及其父节点上的`child watch`。
  - 一个成功的`delete()`操作将会同时触发一个`znode`的`data watch`和`child watch`（因为这样就没有子节点了），同时也会触发其父节点的`child watch`。
- 当一个客户端连接到一个新的服务器上时，`watch`将会被以任意会话事件触发。
  - 当与一个服务器失去连接的时候，是无法接收到`watch`的。而当客户端重新连接时，如果需要的话，所有先前注册过的`watch`，都会被重新注册。通常这是完全透明的。
  - 有在一个特殊情况下，`watch`可能会丢失：对于一个未创建 的`znode`的`exist watch`，如果在客户端断开连接期间被创建了，
    并且随后在客户端连接上之前又删除了，这种情况下，这个`watch`事件可能会被丢失。
- `watch`是轻量级的，其实就是本地`JVM`的`Callback`，服务器端只是存了是否有设置了`watcher`的布尔类型。

## Zookeeper节点ZNode和相关属性

`ZNode`有两种类型 ：
- 持久的（PERSISTENT）：客户端和服务器端断开连接后，创建的节点不删除（默认）。
- 短暂的（EPHEMERAL）：客户端和服务器端断开连接后，创建的节点自己删除。

`ZNode`有四种形式：
- PERSISTENT-持久节点
  - 客户端与`Zookeeper`断开连接后，除非手动删除，否则节点一直存在于`Zookeeper`上
- PERSISTENT_SEQUENTIAL-持久顺序节点
  - 基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。
- EPHEMERAL-临时节点
  - 临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与`Zookeeper`连接断开不一定会话失效），
    那么这个客户端创建的所有临时节点都会被移除。
- EPHEMERAL_SEQUENTIAL-临时顺序节点
  - 基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。

创建`ZNode`时设置顺序标识，`ZNode`名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护。


**节点属性**

`znode`节点不仅可以存储数据，还有一些其他特别的属性。

| 节点属性           | 注解                                                    |
|----------------|-------------------------------------------------------|
| cZxid          | 该数据节点被创建时的事务Id                                        |
| ctime          | 该数据节点创建时间                                             |
| mZxid          | 该数据节点被修改时最新的事物Id                                      |
| mtime          | 该数据节点最后修改时间                                           |
| pZxid          | 当前节点的父级节点事务Id                                         |
| cversion       | 子节点版本号(子节点修改次数，每修改一次值+1递增)                            |
| dataVersion    | 当前节点版本号(每修改一次值+1递增)                                   |
| aclVersion     | 当前节点acl版本号(节点被修改acl权限，每修改一次值+1递增)                     |
| ephemeralOwner | 临时节点标示，当前节点如果是临时节点，则存储的创建者的会话id(sessionId)，如果不是，那么值=0 |
| dataLength     | 当前节点所存储的数据长度                                          |
| numChildren    | 当前节点下子节点的个数                                           |


----
