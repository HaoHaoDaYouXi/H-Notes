# 服务注册与发现
# 服务注册
服务注册就是管理一个记名册，它管理系统内所有的服务地址。</br>
当新的服务启动后，它会向记名册记录自己的地址信息（此信息可以配置的，是由客户端控制告诉服务端的）。</br>
服务的依赖方直接向记名册要`Service Provider`地址就行了。</br>
当下用于服务注册的有很多如：
- `Eureka`
- `ZooKeeper`
- `Nacos`
- 等等

服务注册主要有两种形式：
- 客户端注册
- 第三方注册

## 客户端注册
客户端注册是服务自身要负责注册与注销的工作。当服务启动后向注册中心注册自身，当服务下线时注销自己。</br>
期间还需要和注册中心保持心跳。</br>
心跳不一定要客户端来做，也可以由注册中心负责（这个过程叫探活）。</br>
这种方式的缺点是注册工作与服务耦合在一起，不同语言都要实现一套注册逻辑。</br>

现在大部分的框架都是此类模式。

## 第三方注册（独立的服务`Registrar`）
第三方注册由一个独立的服务`Registrar`负责注册与注销。</br>
当服务启动后以某种方式通知`Registrar`，然后`Registrar`负责向注册中心发起注册工作。</br>
同时注册中心要维护与服务之间的心跳，当服务不可用时，向注册中心注销服务。</br>
这种方式的缺点是`Registrar`必须是一个高可用的系统，否则注册工作没法进展。

# 服务发现
服务发现是指服务自身要负责发现可用服务地址。
根据当前项目使用的服务，查找到对应的服务地址，保证服务可以正常访问。

服务发现主要有两种形式：
- 客户端发现
- 服务端发现

## 客户端发现
客户端发现是指客户端负责查询可用服务地址，以及负载均衡的工作。这种方式最方便直接，而且也方便做负载均衡。</br>
再者一旦发现某个服务不可用立即换另外一个，非常直接。</br>
缺点也在于多语言时的重复工作，每个语言实现相同的逻辑。</br>

## 服务端发现
服务端发现需要额外的`Router`（路由）服务，请求先打到`Router`，然后`Router`负责查询服务与负载均衡。</br>
这种方式虽然没有客户端发现的缺点，但是它的缺点是保证`Router`的高可用。</br>

# Eureka




----
