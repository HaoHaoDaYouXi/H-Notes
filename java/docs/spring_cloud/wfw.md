# 微服务

微服务是一种架构模式，它提倡将单一应用程序划分成一组小的服务。
每个服务运行在其独立的进程中，服务之间通过轻量级通信进行通信。

单个轻量级服务一般为一个单独微服务，微服务讲究的是专注某个功能的实现，
比如登录系统只专注于用户登录方面功能的实现，讲究的是职责单一，开箱即用，可以独立运行。
微服务架构系统是一个分布式的系统，按照业务进行划分服务单元模块，解决单个系统的不足，满足越来越复杂的业务需求。

就目前而言，对于微服务业界并没有一个统一的、标准的定义。

但通常而言，微服务架构是一种架构模式或者说是架构风格，它提倡将单一应用程序划分成一组小的服务。

每个服务运行在其独立的自己的进程中服务之间相互配合、相互协调，为用户提供最终价值。

服务之间采用轻量级通信。

每个服务都围绕具体业务进行构建，并能够独立部署到生产环境等。另外应尽量避免统一的、集中的服务管理机制。

**简单来讲：**

微服务就是一个独立的职责单一的服务应用程序。在`intellij idea`工具里面就是用`maven`开发的一个个独立的`module`，
具体就是使用`springboot`开发的一个小的模块，处理单一专业的业务逻辑，一个模块只做一个事情。

微服务强调的是服务大小，关注的是某一个点，具体解决某一个问题、落地对应的一个服务应用，可以看
做是`idea`里面一个`module`，一个功能就是一个服务。

例如：一个公司有很多部门，但是每个部门负责的职责都是单一的，
比如：财务部门、人事部门、开发部门，都有对应的工作内容，这每个部门就是一个独立的微服务。

## 分布式
微服务都大体认知了，也同时认知下分布式，因为目前的微服务架构，基本都要满足分布式需求。

在《分布式系统原理与范型》一书中有如下定义：
```text
分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统
```

分布式系统是指将一个大型系统分解成多个独立的子系统，并将这些子系统分布在不同的计算机节点上，
由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。

分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。

其目的是利用更多的机器，处理更多的数据。

分布式系统（`distributed system`）是建立在网络之上的软件系统。

分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，
为了解决这些问题又会引入更多的机制、协议，带来更多的问题。
- [`CAP`理论](../other/cap_base.md#cap)
- [`BASE`理论](../other/cap_base.md#base)

## 微服务架构
微服务架构就是对微服务进行管理整合应用的。

微服务架构依赖于微服务，是在微服务基础之上的。

例如：在公司里，每一个部门都是一个独立的微服务，那么公司是一个大型的微服务架构，
就类似董事长可以对下面的部门进行管理。微服务架构主要就是这种功能。

## 微服务的优缺点
- 优点
  - 松耦合，聚焦单一业务功能，无关开发语言，团队规模降低。
  - 小而精，开发中，不需要了解多有业务，只专注于当前功能，便利集中，功能小而精。
  - 高容错，微服务一个功能受损，对其他功能影响并不是太大，可以快速定位问题。
  - 高灵活，可以灵活搭配技术，独立性比较舒服。
- 缺点
  - 高复杂，随着服务数量增加，管理复杂，部署复杂，服务器需要增多，服务通信和调用压力增大，运维工程师压力增大
  - 运维成本高，需要运维工程师，运维成本高。
  - 依赖增强，系统依赖增强，数据一致性，性能监控。

总结：变小变灵活了，数量也变多了，协同性和管理性同步增多。

## 微服务的技术栈

| 微服务组件       | 技术方案                                                         |
|-------------|--------------------------------------------------------------|
| 服务开发        | SpringBoot、Spring、SpringMVC                                  |
| 服务注册与发现     | Nacos、Eurka、Consul、Zookeeper等                                |
| 服务配置与管理     | Nacos、阿里的Dlamond、SpringCloudConfig、Apollo、Netfix公司的Archaius等 |
| 服务路由（API网关） | Gateway、Zuul、Apache APISIX等                                  |
| 服务调用        | Rest（OpenFeign）、RPC（Dubbo）、GRpc等                             |
| 服务熔断器       | Sentinel、Hystrix、Resilience4j等                               |
| 负载均衡        | Nginx、LoadBalancer、Ribbon等                                   |
| 消息队列        | RocketMQ、Kafka、RabbitMQ、ActiveMQ等                            |
| 服务监控        | Prometheus、Zabbix、Nagios、Metrics、Spectator等                  |
| 全链路追踪       | Zipkin，Brave，Dapper等                                         |
| 服务部署        | Docker，OpenStack，Kubernetes等                                 |
| 数据流操作开发包    | SpringCloud Stream（封装与Redis，Rabbit，kafka等发送接收消息）             |
| 事件消息总线      | Nacos、Spring Cloud Bus                                       |

目前主流的微服务开发整体框架方案主要分为2种，`Spring Cloud`和`Spring Cloud Alibaba`。

| 微服务组件  | `Spring Cloud`       | `Spring Cloud Alibaba` |
|--------|----------------------|------------------------|
| 注册与发现  | Eurka、Zookeeper      | Nacos                  |
| 配置与管理  | SpringCloudConfig    | Nacos                  |
| API网关  | Gateway              | Gateway                |
| 服务调用   | OpenFeign            | Dubbo、OpenFeign、GRpc   |
| 熔断器    | Hystrix、Resilience4j | Sentinel               |
| 事件消息总线 | Spring Cloud Bus     | Nacos                  |
| 消息队列   | 随意搭配                 | RocketMQ               |
| 分布式事务  | TCC、Seata、等等         | Seata                  |

两大主流框架的一些区别，其他的基本都是按照各自使用搭配，并无太大区别。

目前使用多的还是`Spring Cloud Alibaba`体系的。

# 服务注册与发现
## 服务注册
服务注册就是管理一个记名册，它管理系统内所有的服务地址。</br>
当新的服务启动后，它会向记名册记录自己的地址信息（此信息可以配置的，是由客户端控制告诉服务端的）。</br>
服务的依赖方直接向记名册要`Service Provider`地址就行了。</br>
当下用于服务注册的有很多如：
- `Eureka`
- `ZooKeeper`
- `Nacos`
- 等等

服务注册主要有两种形式：
- 客户端注册
- 第三方注册

### 客户端注册
客户端注册是服务自身要负责注册与注销的工作。当服务启动后向注册中心注册自身，当服务下线时注销自己。</br>
期间还需要和注册中心保持心跳。</br>
心跳不一定要客户端来做，也可以由注册中心负责（这个过程叫探活）。</br>
这种方式的缺点是注册工作与服务耦合在一起，不同语言都要实现一套注册逻辑。</br>

现在大部分的框架都是此类模式。

### 第三方注册（独立的服务`Registrar`）
第三方注册由一个独立的服务`Registrar`负责注册与注销。</br>
当服务启动后以某种方式通知`Registrar`，然后`Registrar`负责向注册中心发起注册工作。</br>
同时注册中心要维护与服务之间的心跳，当服务不可用时，向注册中心注销服务。</br>
这种方式的缺点是`Registrar`必须是一个高可用的系统，否则注册工作没法进展。

## 服务发现
服务发现是指服务自身要负责发现可用服务地址。
根据当前项目使用的服务，查找到对应的服务地址，保证服务可以正常访问。

服务发现主要有两种形式：
- 客户端发现
- 服务端发现

### 客户端发现
客户端发现是指客户端负责查询可用服务地址，以及负载均衡的工作。这种方式最方便直接，而且也方便做负载均衡。</br>
再者一旦发现某个服务不可用立即换另外一个，非常直接。</br>
缺点也在于多语言时的重复工作，每个语言实现相同的逻辑。</br>

### 服务端发现
服务端发现需要额外的`Router`（路由）服务，请求先打到`Router`，然后`Router`负责查询服务与负载均衡。</br>
这种方式虽然没有客户端发现的缺点，但是它的缺点是保证`Router`的高可用。</br>

# 服务配置与管理

# 服务调用

# API网关

# 负载均衡


# 熔断器


----
