# 微服务

微服务是一种架构模式，它提倡将单一应用程序划分成一组小的服务。
每个服务运行在其独立的进程中，服务之间通过轻量级通信进行通信。

单个轻量级服务一般为一个单独微服务，微服务讲究的是专注某个功能的实现，
比如登录系统只专注于用户登录方面功能的实现，讲究的是职责单一，开箱即用，可以独立运行。
微服务架构系统是一个分布式的系统，按照业务进行划分服务单元模块，解决单个系统的不足，满足越来越复杂的业务需求。

就目前而言，对于微服务业界并没有一个统一的、标准的定义。

但通常而言，微服务架构是一种架构模式或者说是架构风格，它提倡将单一应用程序划分成一组小的服务。

每个服务运行在其独立的自己的进程中服务之间相互配合、相互协调，为用户提供最终价值。

服务之间采用轻量级通信。

每个服务都围绕具体业务进行构建，并能够独立部署到生产环境等。另外应尽量避免统一的、集中的服务管理机制。

**简单来讲：**

微服务就是一个独立的职责单一的服务应用程序。在`intellij idea`工具里面就是用`maven`开发的一个个独立的`module`，
具体就是使用`springboot`开发的一个小的模块，处理单一专业的业务逻辑，一个模块只做一个事情。

微服务强调的是服务大小，关注的是某一个点，具体解决某一个问题、落地对应的一个服务应用，可以看
做是`idea`里面一个`module`，一个功能就是一个服务。

例如：一个公司有很多部门，但是每个部门负责的职责都是单一的，
比如：财务部门、人事部门、开发部门，都有对应的工作内容，这每个部门就是一个独立的微服务。

## 分布式
微服务都大体认知了，也同时认知下分布式，因为目前的微服务架构，基本都要满足分布式需求。

在《分布式系统原理与范型》一书中有如下定义：
```text
分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统
```

分布式系统是指将一个大型系统分解成多个独立的子系统，并将这些子系统分布在不同的计算机节点上，
由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。

分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。

其目的是利用更多的机器，处理更多的数据。

分布式系统（`distributed system`）是建立在网络之上的软件系统。

分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，
为了解决这些问题又会引入更多的机制、协议，带来更多的问题。
- [`CAP`理论](../other/cap_base.md#cap)
- [`BASE`理论](../other/cap_base.md#base)

## 微服务架构
微服务架构就是对微服务进行管理整合应用的。

微服务架构依赖于微服务，是在微服务基础之上的。

例如：在公司里，每一个部门都是一个独立的微服务，那么公司是一个大型的微服务架构，
就类似董事长可以对下面的部门进行管理。微服务架构主要就是这种功能。

## 微服务的优缺点
- 优点
  - 松耦合，聚焦单一业务功能，无关开发语言，团队规模降低。
  - 小而精，开发中，不需要了解多有业务，只专注于当前功能，便利集中，功能小而精。
  - 高容错，微服务一个功能受损，对其他功能影响并不是太大，可以快速定位问题。
  - 高灵活，可以灵活搭配技术，独立性比较舒服。
- 缺点
  - 高复杂，随着服务数量增加，管理复杂，部署复杂，服务器需要增多，服务通信和调用压力增大，运维工程师压力增大
  - 运维成本高，需要运维工程师，运维成本高。
  - 依赖增强，系统依赖增强，数据一致性，性能监控。

总结：变小变灵活了，数量也变多了，协同性和管理性同步增多。

## 微服务的技术栈

| 微服务组件       | 技术方案                                                         |
|-------------|--------------------------------------------------------------|
| 服务开发        | SpringBoot、Spring、SpringMVC                                  |
| 服务注册与发现     | Nacos、Eurka、Consul、Zookeeper等                                |
| 服务配置与管理     | Nacos、阿里的Dlamond、SpringCloudConfig、Apollo、Netfix公司的Archaius等 |
| 服务路由（API网关） | Gateway、Zuul、Apache APISIX等                                  |
| 服务调用        | Rest（OpenFeign）、RPC（Dubbo）、GRpc等                             |
| 服务熔断器       | Sentinel、Hystrix、Resilience4j等                               |
| 负载均衡        | Nginx、LoadBalancer、Ribbon等                                   |
| 消息队列        | RocketMQ、Kafka、RabbitMQ、ActiveMQ等                            |
| 服务监控        | Prometheus、Zabbix、Nagios、Metrics、Spectator等                  |
| 全链路追踪       | Zipkin，Brave，Dapper等                                         |
| 服务部署        | Docker，OpenStack，Kubernetes等                                 |
| 数据流操作开发包    | SpringCloud Stream（封装与Redis，Rabbit，kafka等发送接收消息）             |
| 事件消息总线      | Nacos、Spring Cloud Bus                                       |

目前主流的微服务开发整体框架方案主要分为2种，`Spring Cloud`和`Spring Cloud Alibaba`。

| 微服务组件  | `Spring Cloud`       | `Spring Cloud Alibaba` |
|--------|----------------------|------------------------|
| 注册与发现  | Eurka、Zookeeper      | Nacos                  |
| 配置与管理  | SpringCloudConfig    | Nacos                  |
| API网关  | Gateway              | Gateway                |
| 服务调用   | OpenFeign            | Dubbo、OpenFeign、GRpc   |
| 熔断器    | Hystrix、Resilience4j | Sentinel               |
| 事件消息总线 | Spring Cloud Bus     | Nacos                  |
| 消息队列   | 随意搭配                 | RocketMQ               |
| 分布式事务  | TCC、Seata、等等         | Seata                  |

两大主流框架的一些区别，其他的基本都是按照各自使用搭配，并无太大区别。

目前使用多的还是`Spring Cloud Alibaba`体系的。

# 服务注册与发现
## 服务注册
服务注册就是管理一个记名册，它管理系统内所有的服务地址。</br>
当新的服务启动后，它会向记名册记录自己的地址信息（此信息可以配置的，是由客户端控制告诉服务端的）。</br>
服务的依赖方直接向记名册要`Service Provider`地址就行了。</br>
当下用于服务注册的有很多如：
- `Eureka`
- `ZooKeeper`
- `Nacos`
- 等等

服务注册主要有两种形式：
- 客户端注册
- 第三方注册

### 客户端注册
客户端注册是服务自身要负责注册与注销的工作。当服务启动后向注册中心注册自身，当服务下线时注销自己。</br>
期间还需要和注册中心保持心跳。</br>
心跳不一定要客户端来做，也可以由注册中心负责（这个过程叫探活）。</br>
这种方式的缺点是注册工作与服务耦合在一起，不同语言都要实现一套注册逻辑。</br>

现在大部分的框架都是此类模式。

### 第三方注册（独立的服务`Registrar`）
第三方注册由一个独立的服务`Registrar`负责注册与注销。</br>
当服务启动后以某种方式通知`Registrar`，然后`Registrar`负责向注册中心发起注册工作。</br>
同时注册中心要维护与服务之间的心跳，当服务不可用时，向注册中心注销服务。</br>
这种方式的缺点是`Registrar`必须是一个高可用的系统，否则注册工作没法进展。

## 服务发现
服务发现是指服务自身要负责发现可用服务地址。
根据当前项目使用的服务，查找到对应的服务地址，保证服务可以正常访问。

服务发现主要有两种形式：
- 客户端发现
- 服务端发现

### 客户端发现
客户端发现是指客户端负责查询可用服务地址，以及负载均衡的工作。这种方式最方便直接，而且也方便做负载均衡。</br>
再者一旦发现某个服务不可用立即换另外一个，非常直接。</br>
缺点也在于多语言时的重复工作，每个语言实现相同的逻辑。</br>

### 服务端发现
服务端发现需要额外的`Router`（路由）服务，请求先打到`Router`，然后`Router`负责查询服务与负载均衡。</br>
这种方式虽然没有客户端发现的缺点，但是它的缺点是保证`Router`的高可用。</br>

# 服务配置与管理
随着业务的发展、微服务架构的升级，服务的数量、程序的配置日益增多（各种微服务、各种服务器地址、各种参数）

会出现以下一些问题：
- 安全性：配置跟随源代码保存在代码库中，容易造成配置泄漏。
- 分散性：配置文件过于分散，难以管理。
- 回溯性：而且静态配置文件方式修改无法追溯，所以当配置进行修改之后，不容易形成记录，更无法追溯是谁修改的、修改时间是什么、修改前是什么内容。
- 时效性：修改配置，需要重启服务才能生效。
- 繁琐性：一项配置更改，需要人工修改每一个服务的配置文件。
- 局限性：无法支持动态调整：例如日志开关、功能开关；无法动态切换不同环境。

传统的配置方式已无法满足配置管理的要求，为了更加高效和快捷的获取配置，
因此，我们需要配置中心来统一管理配置，把业务开发者从复杂以及繁琐的配置中解脱出来，
只需专注于业务代码本身，从而能够显著提升开发以及运维效率。
同时将配置和发布包解藕也进一步提升发布的成功率，并为运维的细力度管控、应急处理等提供强有力的支持。

## 配置中心应该满足的特点

- 配置集中管理：解决传统的“配置文件过于分散”的问题。所有的配置都集中在配置中心这一个地方管理，不需要每一个项目都自带一个，这样极大的减轻了开发成本。
- 统一标准
- 配置与应用分离：解决传统的`配置文件无法区分环境`的问题，配置并不跟着环境走，当不同环境有不同需求的时候，就到配置中心获取即可，极大的减轻了运维部署成本。
- 实时更新：解决传统的“静态化配置”的问题。线上系统需要调整参数的时候，只需要在配置中心动态修改即可。
- 高性能、高可用性、高并发、分布式
- 可以基于不同环境配置，做到隔离（开发、测试、预发布、灰度/线上）；

## 变更推送如何实现

配置信息存储之后，我们需要考虑如何将配置的变更推送给服务端，这样就可以实现配置的`动态变更`，不需要重启服务器就能让配置生效了。
而一般会有两种思路来实现变更推送：一种是`轮询查询`的方式；一种是`长连推送`的方式。

轮询查询很简单，就是应用程序向配置中心客户端注册一个监听器，配置中心的客户端，定期地（比如`1`分钟）查询所需要的配置是否有变化，如果有变化则通知触发监听器，让应用程序得到变更通知。 
这里有一个需要注意的点，如果有很多应用服务器都去轮询拉取配置，由于返回的配置项可能会很大，那么配置中心服务的带宽就会成为瓶颈。

为了解决这个问题，会给配置中心的每一个配置项，多存储一个根据配置项计算出来的`MD5`值。
配置项一旦变化，这个`MD5`值也会随之改变。
配置中心客户端在获取到配置的同时，也会获取到配置的`MD5`值，并且存储起来。
那么在轮询查询的时候，需要先确认存储的`MD5`值，和配置中心的`MD5`是不是一致的。
如果不一致，这就说明配置中心中，存储的配置项有变化，然后才会从配置中心拉取最新的配置。 
由于配置中心里存储的配置项变化的几率不大，所以使用这种方式后，每次轮询请求就只是返回一个`MD5`值，可以大大地减少配置中心服务器的带宽。

另一种长连推送，则是在配置中心服务端保存每个连接关注的配置项列表。
这样，当配置中心感知到配置变化后，就可以通过这个连接，把变更的配置推送给客户端。
这种方式需要保持长连，也需要保存连接和配置的对应关系，实现上要比轮询的方式复杂一些，但是相比轮询方式来说，能够更加实时地获取配置变更的消息。

# 服务调用
在微服务架构中，需要调用很多服务才能完成一项功能。服务之间如何互相调用就变成微服务架构中的一个关键问题。

服务调用一般有两种方式，一种是`HTTP`方式，另一种是`RPC`方式。
- `HTTP`（Hypertext Transfer Protocol）是一种应用层协议，主要强调的是网络通信；
- `RPC`（Remote Procedure Call，远程过程调用）是一种用于分布式系统之间通信的协议，强调的是服务之间的远程调用。
  一些`RPC`框架比如`gRPC`，底层传输协议其实也是用的`HTTP2`，包括`Dubbo3`，也兼容了`gRPC`，使用了`HTTP2`作为传输层的一层协议。

目前主流的`OpenFeign`就是`HTTP`方式，`Dubbo`是`RPC`方式。

# API网关
`API`网关是系统对外的访问入口。例如常见的`Nginx`就是`API`网关，它更多是服务器对外的网关。

微服务中的`API`网关，功能更多的是：动态路由、API管理、服务治理、身份认证、安全管理、监控等等基于服务更细微的管控。

# 负载均衡


# 熔断器


----
