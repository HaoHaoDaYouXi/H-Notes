# 锁`Lock`

## `Lock`接口的主要方法
- `void lock()`: 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁.
- `boolean tryLock()`：如果锁可用, 则获取锁, 并立即返回`true`, 否则返回`false`。
   该方法和`lock()`的区别在于, `tryLock()`只是"试图"获取锁, 如果锁不可用, 不会导致当前线程被禁用, 当前线程仍然继续往下执行代码。
   而`lock()`方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行。
- `void unlock()`：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生。
- `Condition newCondition()`：条件对象，获取等待通知组件。
  该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的`await()`方法，而调用后，当前线程将缩放锁。
- `getHoldCount()`：查询当前线程保持此锁的次数，也就是执行此线程执行`lock`方法的次数。
- `getQueueLength()`：返回正等待获取此锁的线程估计数，比如启动`10`个线程，`1`个线程获得锁，此时返回的是`9`。
- `getWaitQueueLength`：(`Condition condition`)返回等待与此锁相关的给定条件的线程估计数。
   比如`10`个线程，用同一个`condition`对象，并且此时这`10`个线程都执行了`condition`对象的`await`方法，那么此时执行此方法返回`10`。
- `hasWaiters(Condition condition)`：查询是否有线程等待与此锁有关的给定条件(`condition`)，对于指定`condition`对象，有多少线程执行了`condition.await`方法。
- `hasQueuedThread(Thread thread)`：查询给定线程是否等待获取此锁。
- `hasQueuedThreads()`：是否有线程等待此锁。
- `isFair()`：该锁是否公平锁。
- `isHeldByCurrentThread()`：当前线程是否保持锁锁定，线程的执行`lock`方法的前后分别是`false`和`true`。
- `isLock()`：此锁是否有任意线程占用。
- `lockInterruptibly()`：如果当前线程未被中断，获取锁。
- `tryLock()`：尝试获得锁，仅在调用时锁未被线程占用，获得锁。
- `tryLock(long timeout, TimeUnit unit)`：如果锁在给定等待时间内没有被另一个线程保持， 则获取该锁。

## <div id="lgs">乐观锁</div>
乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，
但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号。

然后加锁操作(比较跟上一次的版本号，如果一样则更新)，如果失败则要重复读-比较-写的操作。
`Java`中的乐观锁基本都是通过`CAS`操作实现的，`CAS`是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。

## <div id="bgs">悲观锁</div>
悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，
所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会`block`直到拿到锁。

`Java`中的悲观锁就是`Synchronized`，`AQS`框架下的锁则是先尝试`CAS`乐观锁去获取锁，获取不到，才会转换为悲观锁，如`RetreenLock`。

## <div id="zxs">自旋锁</div>
自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，
它们只需要等一等(自旋)，等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。

线程自旋是需要消耗`CPU`的，说白了就是让`CPU`在做无用功，如果一直获取不到锁，那线程也不能一直占用`CPU`自旋做无用功，所以需要设定一个自旋等待的最大时间。

如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。

### 自旋锁的优缺点
自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，
因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！

但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，
因为自旋锁在获取锁前一直都是占用`CPU`做无用功，占着`XX`不`XX`，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，
其它需要`CPU`的线程又不能获取到`CPU`，造成`CPU`的浪费。所以这种情况下我们要关闭自旋锁。

### 自旋锁时间阈值(`1.6`引入了适应性自旋锁)
自旋锁的目的是为了占着`CPU`的资源不释放，等到获取到锁立即进行处理。

**但是如何去选择自旋的执行时间呢？**

如果自旋执行时间太长，会有大量的线程处于自旋状态占用`CPU`资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！

`JVM`对于自旋周期的选择，`jdk1.5`这个限度是一定的写死的，在`1.6`引入了适应性自旋锁，
适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，
基本认为一个线程上下文切换的时间是最佳的一个时间

同时`JVM`还针对当前`CPU`的负荷情况做了较多的优化，
- 如果平均负载小于`CPUs`则一直自旋，如果有超过(`CPUs/2`)个线程正在自旋，则后来线程直接阻塞
- 如果正在自旋的线程发现`Owner`发生了变化则延迟自旋时间(自旋计数)或进入阻塞
- 如果`CPU`处于节电模式则停止自旋，自旋时间的最坏情况是`CPU`的存储延迟(`CPU A`存储了一个数据，到`CPU B`得知这个数据直接的时间差)，自旋时会适当放弃线程优先级之间的差异

### 自旋锁的开启
- `JDK1.6`中`-XX:+UseSpinning`开启
- `-XX:PreBlockSpin=10`为自旋次数
- `JDK1.7`后，去掉此参数，由`jvm`控制

## <div id="tbs">`Synchronized`同步锁</div>
`Synchronized`它可以把任意一个非`NULL`的对象当作锁。他属于独占式的悲观锁，同时属于可重
入锁。

### `Synchronized`作用范围
- 作用于方法时，锁住的是对象的实例(`this`)。
- 当作用于静态方法时，锁住的是`Class`实例，又因为`Class`的相关数据存储在方法区(`Method Area`)
  方法区是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程。
- `Synchronized`作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，
  当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。

### `Synchronized`核心组件
- `Wait Set`：哪些调用`wait`方法被阻塞的线程被放置在这里。
- `Contention List`：竞争队列，所有请求锁的线程首先被放在这个竞争队列中。
- `Entry List`：`Contention List`中那些有资格成为候选资源的线程被移动到`Entry List`中。
- `OnDeck`：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为`OnDeck`。
- `Owner`：当前已经获取到所资源的线程被称为`Owner`。
- `!Owner`：当前释放锁的线程。

## <div id="reentrantlock">`ReentrantLock`</div>
`ReentrantLock`继承接口`Lock`并实现了接口中定义的方法，他是一种可重入锁，除了能完成`synchronized`所能完成的所有工作外，
还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。

`ReentrantLock`在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。
非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。

### `ReentrantLock`与`Synchronized`
- `ReentrantLock`通过方法`lock()`与`unlock()`来进行加锁与解锁操作，与`Synchronized`会被`JVM`自动解锁机制不同，`ReentrantLock`加锁后需要手动进行解锁。
  为了避免程序出现异常而无法正常解锁的情况，使用`ReentrantLock`必须在`finally`控制块中进行解锁操作。
- `ReentrantLock`相比`Synchronized`的优势是可中断、公平锁、多个锁。这种情况下需要使用`ReentrantLock`。

### `Condition`类和`Object`类锁方法区别区别
- `Condition`类的`awiat`方法和`Object`类的`wait`方法等效
- `Condition`类的`signal`方法和`Object`类的`notify`方法等效
- `Condition`类的`signalAll`方法和`Object`类的`notifyAll`方法等效
- `ReentrantLock`类可以唤醒指定条件的线程，而`object`的唤醒是随机的

### `tryLock`和`lock`和`lockInterruptibly`的区别
- `tryLock`能获得锁就返回`true`，不能就立即返回`false`，`tryLock(long timeout,TimeUnit unit)`，可以增加时间限制，如果超过该时间段还没获得锁，返回`false`
- `lock`能获得锁就返回`true`，不能的话一直等待获得锁
- `lock`和`lockInterruptibly`，如果两个线程分别执行这两个方法，但此时中断这两个线程，`lock`不会抛出异常，而`lockInterruptibly`会抛出异常。

## <div id="atomicInteger">`AtomicInteger`</div>
`AtomicInteger`，一个提供原子操作的`Integer`的类，
常见的还有：`AtomicBoolean`、`AtomicInteger`、`AtomicLong`、`AtomicReference`等

他们的实现原理相同，区别在与运算对象类型的不同，还可以通过`AtomicReference<V>`将一个对象的所有操作转化成原子操作。

在多线程程序中，诸如`++i`或`i++`等运算不具有原子性，是不安全的线程操作之一。

通常会使用`synchronized`将该操作变成一个原子操作，但`JVM`为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。

通过相关资料显示，通常`AtomicInteger`的性能是`ReentrantLock`的好几倍。

## <div id="semaphore">`Semaphore`信号量</div>
`Semaphore`是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。

`Semaphore`可以用来构建一些对象池，资源池之类的，比如数据库连接池实现互斥锁(计数器为`1`)

也可以创建计数为`1`的`Semaphore`，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。

### `Semaphore`与`ReentrantLock`
- `Semaphore`基本能完成`ReentrantLock`的所有工作，使用方法也与之类似，通过`acquire()`与`release()`方法来获得和释放临界资源。
- `Semaphore.acquire()`方法默认为可响应中断锁，与`ReentrantLock.lockInterruptibly()`作用效果一致，也就是说在等待临界资源的过程中可以被`Thread.interrupt()`方法中断。
- `Semaphore`也实现了可轮询的锁请求与定时锁的功能，除了方法名`tryAcquire`与`tryLock`不同，其使用方法与`ReentrantLock`几乎一致。
- `Semaphore`也提供了公平与非公平锁的机制，也可在构造函数中进行设定。
- `Semaphore`的锁释放操作也由手动进行，因此与`ReentrantLock`一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在`finally`代码块中完成。


----
