# MySQL

`MySQL`是⼀种关系型数据库，在`Java`企业级开发中⾮常常⽤，因为`MySQL`是开源免费的，并且⽅便扩展。

## <a id="tx">特性</a>

- 开源与成本效益：`MySQL`是开源的，这意味着它可以免费使用，降低了软件许可的成本。
- 跨平台兼容性：`MySQL`可在多种操作系统上运行，包括`Windows`、`Linux`和`macOS`。
- 高性能：`MySQL`通过优化的存储引擎和内存管理提供了高效率的数据处理能力。
- 安全性：`MySQL`提供了强大的安全功能，如用户权限管理和加密数据传输。
- 可扩展性：`MySQL`支持从小型数据库到大型集群的多种部署方式。
- `ACID`遵守：事务处理遵循`ACID`（原子性、一致性、隔离性、持久性）原则，确保数据完整性。
- `SQL`标准支持：`MySQL`支持`SQL92`和`SQL99`标准，以及一些扩展功能。
- 存储引擎：`MySQL`支持多种存储引擎，如`InnoDB`、`MyISAM`和`MEMORY`，每种引擎具有不同的特性和用途。
- 复制和高可用性：`MySQL`支持主从复制和群集配置，以提高可用性和容错性。
- 社区与文档：`MySQL`拥有庞大的开发者社区和详尽的官方文档，易于学习和解决问题。

## <a id="gcbf">构成部分</a>

- 连接器：身份认证和权限相关(登录`MySQL`的时候)。
- 查询缓存：执⾏查询语句的时候，会先查询缓存（`MySQL 8.0`版本后移除，因为这个功能不太实⽤）。
- 分析器：没有命中缓存的话，`SQL`语句就会经过分析器，分析器说⽩了就是要先看你的`SQL`语句要⼲嘛，再检查你的`SQL`语句语法是否正确。
- 优化器：按照`MySQL`认为最优的⽅案去执⾏。
- 执⾏器：执⾏语句，然后从存储引擎返回数据。 执⾏语句之前会先判断是否有权限，如果没有权限的话，就会报错。
- 插件式存储引擎：主要负责数据的存储和读取，采⽤的是插件式架构，⽀持`InnoDB`、`MyISAM`、`Memory`等多种存储引擎。

## <a id="sfs">三范式</a>

- 第一范式：每个列都不可以再拆分。
- 第二范式：非主键列完全依赖于主键，而不能是依赖于主键的一部分。
- 第三范式：非主键列只依赖于主键，不依赖于其他非主键。

在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由，比如性能。
事实上经常会为了性能而妥协数据库的设计。

## <a id="ccyq">存储引擎</a>

可以通过`select version()`命令查看你的`MySQL`版本。

`MySQL`⽀持多种存储引擎，可以通过`show engines`命令来查看`MySQL`⽀持的所有存储引擎。

也可以通过`show variables like '%storage_engine%'`命令直接查看`MySQL`当前默认的存储引擎。

如果你只想查看数据库中某个表使⽤的存储引擎的话，可以使⽤`show table status from db_name where name='table_name'`命令。

`MySQL 5.5.5`之前，`MyISAM`是`MySQL`的默认存储引擎。`5.5.5`版本之后，`InnoDB`是`MySQL`的默认存储引擎。
所有的存储引擎中只有`InnoDB`是事务性存储引擎，只有`InnoDB`⽀持事务。

## <a id="gljb">隔离级别</a>

`MySQL`数据库为我们提供的四种隔离级别：

- `Serializable`(串行化)：可避免脏读、不可重复读、幻读的发生。
- `Repeatable read`(可重复读)：可避免脏读、不可重复读的发生。
- `Read committed`(读已提交)：可避免脏读的发生。
- `Read uncommitted`(读未提交)：最低级别，任何情况都无法保证。

`InnoDB`存储引擎的默认⽀持的隔离级别是`Repeatable read`（可重复读）。

可以通过`SELECT @@tx_isolation`命令来查看，
`MySQL 8.0`该命令改为`SELECT @@transaction_isolation`

## <a id="myisaminnodb">`MyISAM`和`InnoDB`的区别</a>

| 区别                                    | MyISAM                           | Innodb                |
|---------------------------------------|----------------------------------|-----------------------|
| 文件格式                                  | 数据和索引是分别存储的数据`.MYD`，索引`.MYI`     | 数据和索引是集中存储的，`.ibd`    |
| 文件能否移动                                | 能，一张表就对应`.frm`、`MYD`、`MYI`3个文件   | 否，因为关联的还有`data`下的其它文件 |
| 记录存储顺序                                | 按记录插入顺序保存                        | 按主键大小有序插入             |
| 空间碎片(删除记录并`flush table`表名 之后，表文件大小不变) | 产生，定时整理，使用命令`optimize table`表名实现 | 不产生                   |
| 事务                                    | 不支持                              | 支持                    |
| 外键                                    | 不支持                              | 支持                    |
| 全文索引                                  | 支持                               | 不支持                   |
| 锁支持(锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的)    | 表级锁                              | 行级锁、表级锁，锁定粒度小并发能力高    |
| MVCC(多版本并发控制)                         | 不支持                              | 支持                    |

## <a id="bjsyjshjs">表级锁、页级锁和⾏级锁</a>

### 表级锁

`MySQL`中锁定粒度最⼤的⼀种锁，是针对⾮索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也⽐较少，加锁快，不会出现死锁。
其锁定粒度最⼤，触发锁冲突的概率最⾼，并发度最低，`MyISAM`和`InnoDB`引擎都⽀持表级锁。

### 页级锁

开销和加锁时间界于表锁和行锁之间，会出现死锁，锁定粒度界于表锁和行锁之间，并发度一般

### ⾏级锁

`MySQL`中锁定粒度最⼩的⼀种锁，是针对索引字段加的锁，只针对当前操作的⾏记录进⾏加锁。⾏级锁能⼤⼤减少数据库操作的冲突。
其加锁粒度最⼩，并发度⾼，但加锁的开销也最⼤，加锁慢，会出现死锁。

`InnoDB`的⾏锁是针对索引字段加的锁，表级锁是针对⾮索引字段加的锁。

当我们执⾏`UPDATE`、`DELETE`语句时，如果`WHERE`条件中字段没有命中唯⼀索引或者索引失效的话，
就会导致扫描全表对表中的所有⾏记录进⾏加锁，⼀定要多注意

不过，很多时候即使⽤了索引也有可能会⾛全表扫描，这是因为`MySQL`优化器的原因。

## <a id="gxspts">共享锁和排他锁</a>

不论是表级锁还是⾏级锁，都存在共享锁（`Share Lock`，`S`锁）和排他锁（`Exclusive Lock`，`X`锁）

- 共享锁（`S`锁）：⼜称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。
- 排他锁（`X`锁）：⼜称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。
  如果⼀个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。

排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。

`MVCC`的存在，对于⼀般的`SELECT`语句，`InnoDB`不会加任何锁。

可以通过以下语句显式加共享锁或排他锁
```sql
-- 共享锁
SELECT ... LOCK IN SHARE MODE;
-- 排他锁
SELECT ... FOR UPDATE;
```

## <a id="yxs">意向锁</a>

意向锁的可以快速判断是否可以对某个表使⽤表锁

意向锁是表级锁，共有两种

- 意向共享锁（`Intention Shared Lock`，`IS`锁）
  - 事务有意向对表中的某些加共享锁（`S`锁），加共享锁前必须先取得该表的`IS`锁。

- 意向排他锁（`Intention Exclusive Lock`，`IX`锁）
  - 事务有意向对表中的某些记录加排他锁（`X`锁），加排他锁之前必须先取得该表的`IX`锁。

意向锁是由数据引擎维护的，⽆法⼿动操作意向锁，在为数据⾏加共享锁、排他锁之前，`InnoDB`会先获取该数据⾏所在在数据表的对应意向锁。

意向锁之间是互相兼容的。

意向锁和表级的共享锁和排他锁互斥，⾏级的共享锁和排他锁不互斥。

## <a id="hs">`InnoDB`⾏锁</a>

`InnoDB`⽀持三种⾏锁定⽅式：
- 记录锁（`Record Lock`）：也被称为记录锁，属于单个⾏记录上的锁。
- 间隙锁（`Gap Lock`）：锁定⼀个范围，不包括记录本身。
- 临键锁（`Next-key Lock`）：`Record Lock`+`Gap Lock`，锁定⼀个范围，包含记录本身，记录锁锁已经存在的，间隙锁锁新插⼊的。

`InnoDB`的默认隔离级别`RR`（可重读）是可以解决幻读问题发⽣的，主要有下⾯两种情况：

- 快照读（⼀致性⾮锁定读）：由`MVCC`机制来保证不出现幻读。
- 当前读（⼀致性锁定读）：使⽤`Next-Key Lock`进⾏加锁来保证不出现幻读。

### 当前读和快照读区别

快照读（⼀致性⾮锁定读）就是单纯的`SELECT`语句，不包括下⾯的`SELECT`语句：
```sql
SELECT ... FOR UPDATE
SELECT ... LOCK IN SHARE MODE
```
快照即记录的历史版本，每⾏记录可能存在多个历史版本（多版本技术）。

快照读的情况下，如果读取的记录正在执⾏ UPDATE/DELETE 操作，读取操作不会因此去等待记录上`X`锁的释放，⽽是会去读取⾏的⼀个快照。

只有在事务隔离级别`RC`（读取已提交）和`RR`（可重读）下，`InnoDB`才会使⽤⼀致性⾮锁定读：

- 在`RC`级别下，对于快照数据，⼀致性⾮锁定读总是读取被锁定⾏的最新⼀份快照数据。
- 在`RR`级别下，对于快照数据，⼀致性⾮锁定读总是读取本事务开始时的⾏数据版本。

快照读⽐较适合对于数据⼀致性要求不是特别⾼且追求极致性能的业务场景。

当前读 （⼀致性锁定读）就是给⾏记录加`X`锁或`S`锁。

当前读的⼀些常⻅`SQL`语句类型如下：
```sql
-- 对读的记录加⼀个X锁
SELECT...FOR UPDATE
-- 对读的记录加⼀个S锁
SELECT...LOCK IN SHARE MODE
-- 对修改的记录加⼀个X锁
INSERT...
UPDATE...
DELETE...
```

## <a id="sy">索引</a>

索引是一种数据结构，可以帮助我们快速的进行数据的查找。

索引的数据结构和具体存储引擎的实现有关，在`MySQL`中使用较多的索引有`Hash`索引，`B+`树索引等

`InnoDB`存储引擎的默认索引实现为：`B+`树索引

### 索引分类

- 单值索引：即一个索引只包含单个列，一个表可以有多个单列索引
  - 建表时，加上`key`(列名) 指定
  - 单独创建，`create index 索引名 on 表名(列名)`
  - 单独创建，`alter table 表名 add index 索引名(列名)`

- 唯一索引：索引列的值必须唯一，但允许有`null`且`null`可以出现多次
  - 建表时，加上`unique(列名)`指定
  - 单独创建，`create unique index idx_表名_列名 on 表名(列名)`
  - 单独创建，`alter table 表名 add unique 索引名(列名)`

- 主键索引：设定为主键后数据库会自动建立索引，`Innodb`为聚簇索引，值必须唯一且不能为`null`
  - 建表时，加上`primary key(列名)`指定

- 复合索引：即一个索引包含多个列
  - 建表时，加上`key(列名列表)`指定
  - 单独创建，`create index 索引名 on 表名(列名列表)`
  - 单独创建，`alter table 表名 add index 索引名(列名列表)`

###  唯一索引和普通索引

唯一索引不一定比普通索引快，还可能慢。

- 查询时， 在未使用`limit 1`的情况下，在匹配到一条数据后，唯一索引即返回，普通索引会继续匹配下一条数据，发现不匹配后返回。
  - 唯一索引少了一次匹配，但实际上这个消耗微乎其微。

- 更新时，比较复杂
  - 普通索引将记录放到`change buffer`中语句就执行完了。
  - 唯一索引，必须要校验唯一性，必须将数据页读入内存确定没有冲突，然后才能继续操作。

写多读少的情况，普通索引利用`change buffer`有效减少了对磁盘的访问次数，普通索引性能要高于唯一索引。

### `B-Tree`和`B+Tree`

#### 区别

- 存放结构
  - `B-Tree`的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息
  - `B+Tree`的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中

- 查找时间
  - `B-Tree`中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在
  - `B+Tree`中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字

从查找时间看`B-Tree`的要比`B+Tree`好，在实际应用中是`B+Tree`的要好些。

因为`B+Tree`的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比`B-Tree`多，树高比`B-Tree`小，这样带来的好处是减少磁盘访问次数。

`B+Tree`找到一个记录所需的比较次数要比`B-Tree`多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，
因此实际中`B+Tree`的性能还会好些，
而且`B+Tree`的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有文件，一个表中的所有记录等），
这也是很多数据库和文件系统使用`B+Tree`的缘故。

#### 总结

- `B+Tree`的磁盘读写代价更低
  - `B+Tree`的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对`B-Tree`更小。
  - 如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。
  - 一次性读入内存中的需要查找的关键字也就越多。相对来说`IO`读写次数也就降低了。

- `B+Tree`的查询效率更加稳定
  - 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。
  - 所以任何关键字的查找必须走一条从根结点到叶子结点的路。
  - 所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

### `Hash`索引和`B+`树

#### `Hash`索引

`Hash`索引底层就是`Hash`表，进行查找时，调用一次`Hash`函数就可以获取到相应的键值，之后进行回表查询获得实际数据。

#### `B+`树

`B+`树底层实现是多路平衡查找树，对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。

#### 不同

`Hash`索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。

因为在`Hash`索引中经过`Hash`函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。

而`B+`树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。

`Hash`索引不支持使用索引进行排序，原理同上。

`Hash`索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为`Hash`函数的不可预测。`AAAA`和`AAAAB`的索引没有相关性。

`Hash`索引任何时候都避免不了回表查询数据，而`B+`树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。

`Hash`索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生`Hash`碰撞，此时效率可能极差。

而`B+`树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。

因此，在大多数情况下，直接选择`B+`树索引可以获得稳定且较好的查询速度。而不需要使用`Hash`索引。

### 聚簇索引

在`B+`树的索引中，叶子节点可能存储了当前的`key`值，也可能存储了当前的`key`值以及整行的数据，这就是非聚簇索引和聚簇索引。

`InnoDB`中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。

如果没有唯一键，则隐式的生成一个键来建立聚簇索引。

当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。

### 非聚簇索引回表查询

这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。

举个例子：假设在员工表的年龄上建立了索引

当进行`select age from employee where age < 20`时，在索引的叶子节点上，已经包含了`age`信息，不会再次进行回表查询。

## <a id="explain">`Explain`性能分析</a>

使用`EXPLAIN`关键字可以模拟优化器执行`SQL`查询语句，可以知道`MySQL`是如何处理`SQL`语句的。分析查询语句或是表结构的性能瓶颈。

### 字段解释

- `id`：`select`查询的序列号，包含一组数字，表示查询中执行`select`子句或操作表的顺序。
  - `id`相同，执行顺序由上至下
  - `id`不同，如果是子查询，`id`的序号会递增，`id`值越大优先级越高，越先被执行
  - `id`有相同也有不同：`id`如果相同，可以认为是一组，从上往下顺序执行；在所有组中，`id`值越大，优先级越高，越先执行

`id`号每个号码，表示一趟独立的查询。一个`sql`的查询趟数越少越好。

- `select_type`：代表查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询
  - `simple`：表示不需要`union`操作或者不包含子查询的简单查询。
  - `primary`：表示最外层查询。
  - `union`：`union`操作中第二个及之后的查询。
  - `dependent union`：`union`操作中第二个及之后的查询，并且该查询依赖于外部查询。
  - `subquery`：子查询中的第一个查询。
  - `dependent subquery`：子查询中的第一个查询，并且该查询依赖于外部查询。
  - `derived`：派生表查询，既from字句中的子查询。
  - `materialized`：物化查询。
  - `uncacheable subquery`：无法被缓存的子查询，对外部查询的每一行都需要重新进行查询。
  - `uncacheable union`：`union`操作中第二个及之后的查询，并且该查询属于`uncacheable subquery`。

- `table`：这个数据是基于哪张表的。

- `type`：是查询的访问类型。是较为重要的一个指标，
  - 结果值从最好到最坏依次是：`system`>`const`>`eq_ref`>`ref`>`fulltext`>`ref_or_null`>`index_merge`>`unique_subquery`>`index_subquery`>`range`>`index`>`ALL`，
  - 一般来说，得保证查询至少达到`range`级别，最好能达到`ref`。
  - 常见的：`system`>`const`>`eq_ref`>`ref`>`range`>`index`>`ALL`，其他的不常见。
    - `system`：表只有一行记录（等于系统表），这是`const`类型的特列，平时不会出现，这个也可以忽略不计。
    - `const`：表示通过索引一次就找到了，`const`用于比较`primary key`或者`unique`索引。因为只匹配一行数据，所以很快。如将主键置于`where`列表中，`MySQL`就能将该查询转换为一个常量。
    - `eq_ref`：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。
    - `ref`：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。
    - `range`：只检索给定范围的行，使用一个索引来选择行。`key`列显示使用了哪个索引一般就是在`where`语句中出现了`between`、`<`、`>`、`in`等的查询这种范围扫描索引扫描比全表扫描要好，
      因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。
    - `index`：出现`index`是`sql`使用了索引但是没用索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组。
    - `all`：将遍历全表以找到匹配的行。
    - 其他`type`：
      - `index_merge`：在查询过程中需要多个索引组合使用，通常出现在有`or`关键字的`sql`中。
      - `ref_or_null`：对于某个字段既需要过滤条件，也需要`null`值的情况下。查询优化器会选择用`ref_or_null`连接查询。
      - `index_subquery`：利用索引来关联子查询，不再全表扫描。
      - `unique_subquery`：该联接类型类似于`index_subquery`。子查询中的唯一索引。

- `possible_keys`：显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。

- `key`：实际使用的索引。如果为`NULL`，则没有使用索引。

- `key_len`：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。`key_len`显示的值为索引字段的最大可能长度，并非实际使用长度。
  计算`key_len`，先看索引上字段的类型 + 长度，比如：`int=4;` `varchar(20)=20;` `char(20)=20`
  如果是`varchar`或者`char`这种字符串字段，视字符集要乘不同的值，比如`utf-8`要乘`3`，`GBK`要乘`2`，`varchar`这种动态字符串要加`2`个字节，允许为空的字段要加`1`个字节

- `ref`：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。

- `rows`：显示`MySQL`认为它执行查询时必须检查的行数。越少越好！

- `Extra`：其他的额外重要的信息。
  - `Using filesort`：说明`MySQL`会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。
  - `MySQL`中无法利用索引完成的排序操作称为`文件排序`。排序字段若通过索引去访问将大大提高排序速度。
  - `Using temporary`：使用临时表保存中间结果，`MySQL`在对查询结果排序时使用临时表。常见于排序`order by`和分组查询`group by`。
  - `Using index`：表示相应的`select`操作中使用了覆盖索引(`Covering Index`)，避免访问了表的数据行，效率不错！
    如果同时出现`using where`，表明索引被用来执行索引键值的查找；
    如果没有同时出现`using where`，表明索引只是用来读取数据而非利用索引执行查找。
  - `Using where`：表明使用了`where`过滤。
  - `Using join buffer`：使用了连接缓存。
  - `impossible where`：`where`子句的值总是`false`，不能用来获取任何数据。
  - `select tables optimized away`：在没有`group by`子句的情况下，基于索引优化`MIN`、`MAX`操作或者对于`MyISAM`存储引擎优化`COUNT(*)`操作，
    不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。
  - `distinct`：优化`distinct`操作，在找到第一匹配的元祖后即停止找同样值的动作。

## <a id="sqlyh">`SQL`优化</a>

简单概括就是：能少查就少查，能少排序就少排序，能少计算就少计算。

例如：
使用`in`时，尽量控制好数量，查询一条数据时加上`limit 1`，能使用索引就使用索引，少使用`or`，模糊查询少使用`%`开头，等等。

减少数据库的操作，就可以提高查询效率。

## <a id="ccgc">存储过程</a>

存储过程是数据库程序，可以理解为数据库函数，但区别在于存储过程可以执行多条`sql`语句，而函数只能执行一条。

通过系统表`information_schema.ROUTINES`查看存储过程的详细信，
`information_schema.ROUTINES`是数据库中一个系统表，存储了所有存储过程、函数、触发器的详细信息，包括名称、返回值类型、参数、创建时间、修改时间等。
```sql
select * from information_schema.routines where routine_name = 'test';
```
`information_schema.ROUTINES`表中的列：

- `SPECIFIC_NAME`：存储过程的具体名称，包括该存储过程的名字，参数列表。
- `ROUTINE_SCHEMA`：存储过程所在的数据库名称。
- `ROUTINE_NAME`：存储过程的名称。
- `ROUTINE_TYPE`：`PROCEDURE`表示是一个存储过程，`FUNCTION`表示是一个函数。
- `ROUTINE_DEFINITION`：存储过程的定义语句。
- `CREATED`：存储过程的创建时间。
- `LAST_ALTERED`：存储过程的最后修改时间。
- `DATA_TYPE`：存储过程的返回值类型、参数类型等。

### 使用

创建存储过程：
```sql
create procedure test()
begin
	select id,name from user;
end;
```

调用
```sql
call test();
```

查看创建存储过程的语句：
```sql
show create procedure test;
```
- Procedure：存储过程名称
- Create Procedure：创建存储过程语句
- Definer：存储过程创建者
- sql_mode：SQL模式
- character_set_client：客户端字符集
- collation_connection：连接字符集
- Database Collation：数据库字符集

删除
```sql
drop procedure if exists test;
```

存储过程还可以声明参数、传参、循环、条件判断等等。

假设我们有一个名为`employees`的表，包含员工信息，我们想要找出所有部门中薪资低于平均薪资的员工，并更新他们的薪资为平均薪资的1.1倍。
```sql
-- 定义分隔符：`DELIMITER`。这改变了MySQL命令的默认分隔符，
-- 使得存储过程中可以包含多个SQL语句。
-- $$通常用于定义存储过程或函数的开始和结束
DELIMITER $$

-- 选择数据库my：USE `my`。
-- 这指示MySQL使用名为my的数据库。
USE `my`$$

-- 删除如果已存在的存储过程：DROP PROCEDURE IF EXISTS `UpdateSalariesBelowAverage`。
-- 如果存储过程`StatisticsForDay1`已经存在，则删除它。
DROP PROCEDURE IF EXISTS `UpdateSalariesBelowAverage`$$

CREATE PROCEDURE UpdateSalariesBelowAverage(IN department_id INT)
BEGIN
    -- 声明局部变量
    DECLARE done INT DEFAULT FALSE;
    DECLARE emp_id, emp_salary, avg_salary INT;
    DECLARE cur CURSOR FOR SELECT id, salary FROM employees WHERE department_id = department_id;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    -- 计算指定部门的平均薪资
    SELECT AVG(salary) INTO avg_salary FROM employees WHERE department_id = department_id;

    -- 打开游标
    OPEN cur;

    read_loop: LOOP
        -- 从游标中获取数据
        FETCH cur INTO emp_id, emp_salary;

        -- 检查是否到达游标末尾
        IF done THEN
            LEAVE read_loop;
        END IF;

        -- 判断员工薪资是否低于平均薪资
        IF emp_salary < avg_salary THEN
            -- 更新员工薪资为平均薪资的1.1倍
            UPDATE employees SET salary = avg_salary * 1.1 WHERE id = emp_id AND department_id = department_id;
        END IF;
    END LOOP;

    -- 关闭游标
    CLOSE cur;
END$$

DELIMITER ;
```
这个存储过程中：
- 首先定义了一个输入参数`department_id`，用于指定要处理的部门。
- 声明了几个局部变量，包括`done`标记游标是否结束，`emp_id`和`emp_salary`用于存储从游标中读取的员工ID和薪资，`avg_salary`用于存储部门的平均薪资。
- 使用`CURSOR`创建了一个游标，用于遍历指定部门的所有员工。
- 计算了指定部门的平均薪资。
- 使用`LOOP`循环遍历游标中的每一项，如果员工的薪资低于平均薪资，则更新该员工的薪资为平均薪资的1.1倍。
- 最后，关闭游标，完成存储过程。

这个存储过程可以被调用，传入具体的部门`ID`，然后自动找出并更新薪资低于平均值的员工信息。

## <a id="fkfb">分库分表</a>



## <a id="dxfl">读写分离</a>



## <a id="bfhf">备份和恢复</a>




----
