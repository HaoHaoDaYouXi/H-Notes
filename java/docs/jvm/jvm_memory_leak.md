# 内存泄露、溢出

### 为什么要了解内存泄露和内存溢出？

- 内存泄露一般是代码设计存在缺陷导致的，通过了解内存泄露的场景，可以避免不必要的内存溢出和提高自己的代码编写水平。
- 通过了解内存溢出的几种常见情况，可以在出现内存溢出的时候快速的定位问题的位置，缩短解决故障的时间。

### 基本概念理解这两个概念非常重要

- 内存泄露：
    -  指程序中动态分配内存给一些临时对象，但是对象不会被GC所回收，它始终占用内存。即被分配的对象可达但已无用。
- 内存溢出：
    - 指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。

从定义上可以看出内存泄露是内存溢出的一种诱因，不是唯一因素。

### 二者的关系

#### 内存泄漏的堆积最终会导致内存溢出

* 内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。

> 内存泄漏
>> 是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，
结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），
而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，
你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，
那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。

> 内存溢出
>> 一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。
这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。
就是分配的内存不足以放下数据项序列,称为内存溢出。简单说就是承受不了那么多，就报错。

### 内存泄漏的分类（按发生方式来分类）

* 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。

* 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。
常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。
所以测试环境和测试方法对检测内存泄漏至关重要。

* 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。
比如，在类的构造函数中分配内存，在构造函数中却没有释放该内存，所以内存泄漏只会发生一次。

* 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。
严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。
但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。
所以，我们称这类内存泄漏为隐式内存泄漏。

### 内存泄露的几种场景：

1、长生命周期的对象持有短生命周期对象的引用

这是内存泄露最常见的场景，也是代码设计中经常出现的问题。

- 例如：在全局静态map中缓存局部变量，且没有清空操作，随着时间的推移，
    这个map会越来越大，造成内存泄露。

2、修改hashset中对象的参数值，且参数是计算哈希值的字段
   
- 当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段，
否则对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，
在这种情况下，即使在contains方法使用该对象的当前引用作为参数去HashSet集合中检索对象，
也将返回找不到对象的结果，这也会导致无法从HashSet集合中删除当前对象，造成内存泄露。 

3、机器的连接数和关闭时间设置

- 长时间开启非常耗费资源的连接，也会造成内存泄露。

### 内存溢出的几种情况：

1、堆内存溢出（outOfMemoryError：java heap space）

在jvm规范中，堆中的内存是用来生成对象实例和数组的。
如果细分，堆内存还可以分为年轻代和年老代，年轻代包括一个eden区和两个survivor区。

当生成新对象时，内存的申请过程如下：

- jvm先尝试在eden区分配新建对象所需的内存；
- 如果内存大小足够，申请结束，否则下一步；
- jvm启动youngGC，试图将eden区中不活跃的对象释放掉，
释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区；
- Survivor区被用来作为Eden及old的中间交换区域，当OLD区空间足够时，
Survivor区的对象会被移到Old区，否则会被保留在Survivor区；
- 当OLD区空间不够时，JVM会在OLD区进行full GC；
- full GC后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，
导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误”：
outOfMemoryError：java heap space

代码举例：
~~~
/**
 * 堆内存溢出
 *
 * jvm参数：-Xms5m -Xmx5m -Xmn2m -XX:NewSize=1m
 *
 */
public class MemoryLeak {

    private String[] s = new String[1000];

    public static void main(String[] args) throws InterruptedException {
        Map<String,Object> m =new HashMap<String,Object>();
        int i =0;
        int j=10000;
        while(true){
            for(;i<j;i++){
                MemoryLeak memoryLeak = new MemoryLeak();
                m.put(String.valueOf(i), memoryLeak);
            }
        }
    }
}
~~~          

2、方法区内存溢出（outOfMemoryError：permgem space）

在jvm规范中，方法区主要存放的是类信息、常量、静态变量等。
所以如果程序加载的类过多，或者使用反射、gclib等这种动态代理生成类的技术，
就可能导致该区发生内存溢出，一般该区发生内存溢出时的错误信息为：
java.lang.OutOfMemoryError: PermGen space(1.8以前)或者java.lang.OutOfMemoryError: Metaspace(1.8及以后)

代码举例：
~~~
jvm参数：-XX:PermSize=100M -XX:MaxPermSize=100M
以上时1.8以前的
1.8及以后的为：-XX:MetaspaceSize=100M -XX:MaxMetaspaceSize=100m
~~~

将方法区的大小设置很低即可，在启动加载类库时就会出现内存不足的情况


3、线程栈溢出（java.lang.StackOverflowError）

线程栈时线程独有的一块内存结构，所以线程栈发生问题必定是某个线程运行时产生的错误。
一般线程栈溢出是由于递归太深或方法调用层级过多导致的。

发生栈溢出的错误信息为：java.lang.StackOverflowError

代码举例：
~~~
/**
 * 线程操作栈溢出
 *
 * 参数：-Xms5m -Xmx5m -Xmn2m -XX:NewSize=1m -Xss64k
 *
 */
public class StackOverflowTest {
    public static void main(String[] args) {
        int i =0;
        digui(i);
    }
   
    private static void digui(int i){
        System.out.println(i++);
        String[] s = new String[50];
        digui(i);
    }
}
~~~

### 避免内存泄露：
1. 尽早释放无用对象的引用

2. 使用字符串处理，避免使用String，应大量使用StringBuffer，
每一个String对象都得独立占用内存一块区域

3. 尽量少用静态变量，因为静态变量存放在永久代（方法区），永久代基本不参与垃圾回收

4. 避免在循环中创建对象

5. 开启大型文件或从数据库一次拿了太多的数据很容易造成内存溢出，
所以在这些地方要大概计算一下数据量的最大值是多少，
并且设定所需最小及最大的内存空间值。 

### 内存溢出的解决方案：

1. 第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)

2. 第二步，检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。

3. 第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。
重点排查以下几点：
    - 检查代码中是否有死循环或递归调用。
    - 检查是否有大循环重复产生新对象实体。
    - 检查对数据库查询中，是否有一次获得全部数据的查询。
    一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。
    这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，
    数据库中数据多了，一次查询就有可能引起内存溢出。
    因此对于数据库查询尽量采用分页的方式查询。
    - 检查List、MAP等集合对象是否有使用完后，未清除的问题。
    List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。

4. 第四步，使用内存查看工具动态查看内存使用情况


### <a id="ncyccl">记一次内存泄露、溢出处理流程：</a>

处理内存泄露、溢出的前提得知道如何更快的定位内存的原因，一般情况就是一次性申请对象过多、内存没有释放、项目内存分配的不够多

大体的情况都清楚时，就需要定位问题出现点，并解决问题

定位问题一般就是通过堆信息判断，所以：
1. 第一步就是获取堆信息，
    - 项目已经OOM挂了，并且没有配置HeapDump文件时，只能根据项目运行日志判断，若项目也没有配置运行日志，那基本无法判断了，所以最好配置好HeapDump文件
      - HeapDump配置：-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=文件目录
    - 项目还未OOM，这时可以通过jmap指令导出堆信息，或者通过Arthas这类的
      - jmap指令：jmap -dump:format=b,file=文件名.hprof 进程ID
2. 第二步解析堆信息文件，下载获取到的堆信息文件，然后可以通过JavaVisualVM软件解析堆文件，通过解析的内容可以看到对象的占用，根据占用情况查看使用情况可以定位到代码位置
3. 第三步解决问题，根据定位到的代码问题或者内存分配导致的相关问题做对应的处理
4. 如果怀疑是内存释放导致的问题时可以查看下方法区的大小是否设置的大于分配的内容，导致一直无法进行释放
