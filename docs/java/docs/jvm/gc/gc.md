# Java垃圾回收机制(GC)

### 垃圾回收机制的意义
　　Java语言中一个显著的特点就是引入了垃圾回收机制，
使c++程序员最头疼的内存管理的问题迎刃而解，
它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，
Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。
垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。

JVM 内存模型一共包括三个部分：

    堆 ( Java代码可及的 Java堆 和 JVM自身使用的方法区)

    栈 ( 服务Java方法的虚拟机栈 和 服务Native方法的本地方法栈 ) 

    保证程序在多线程环境下能够连续执行的程序计数器。

　　特别地，我们当时就提到Java堆是进行垃圾回收的主要区域，
故其也被称为GC堆；而方法区也有一个不太严谨的表述，就是永久代。

总的来说，堆 (包括Java堆 和 方法区)是 垃圾回收的主要对象，特别是Java堆。

　　实际上，Java技术体系中所提倡的 自动内存管理 
最终可以归结为自动化地解决了两个问题：给对象分配内存 以及回收分配给对象的内存，
而且这两个问题针对的内存区域就是Java内存模型中的堆区。

　　另外，我们知道垃圾回收机制是Java语言一个显著的特点，
其可以有效的防止内存泄露、保证内存的有效使用，
从而使得Java程序员在编写程序的时候不再需要考虑内存管理问题。
Java 垃圾回收机制要考虑的问题很复杂。

本文阐述了其三个核心问题，包括：

- 那些内存需要回收？(对象是否可以被回收的两种经典算法: 引用计数法 和 可达性分析算法)

- 什么时候回收？ （堆的新生代、老年代、永久代的垃圾回收时机，MinorGC 和 FullGC）

- 如何回收？(三种经典垃圾回收算法(标记清除算法、复制算法、标记整理算法)及分代收集算法 和 七种垃圾收集器)

　　在探讨Java垃圾回收机制之前，我们首先应该记住一个单词：Stop-the-World。
Stop-the-world意味着 JVM由于要执行GC而停止了应用程序的执行，
并且这种情形会在任何一种GC算法中发生。当Stop-the-world发生时，
除了GC所需的线程以外，所有线程都处于等待状态直到GC任务完成。
事实上，GC优化很多时候就是指减少Stop-the-world发生的时间，
从而使系统具有 高吞吐 、低停顿 的特点。

　　Ps:内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，
Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，
我们有时也将其称为“对象游离”。
