# Java垃圾回收机制(GC)

### 垃圾回收机制的意义

`Java`语言中一个显著的特点就是引入了垃圾回收机制，使`c++`程序员最头疼的内存管理的问题迎刃而解，它使得`Java`程序员在编写程序的时候不再需要考虑内存管理。

  由于有个垃圾回收机制，`Java`中的对象不再有`作用域`的概念，只有对象的引用才有`作用域`。
垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。

`JVM`内存模型一共包括三个部分：

- `堆`(`Java`代码可及的`Java堆`和`JVM`自身使用的`方法区`)
- `栈`(服务`Java`方法的虚拟机栈和服务`Native`方法的`本地方法栈`) 
- 保证程序在多线程环境下能够连续执行的`程序计数器`。

`Java堆`是进行垃圾回收的主要区域，故其也被称为`GC堆`；而方法区也有一个不太严谨的表述，就是`永久代`。

总的来说，`堆`(包括`Java堆`和`方法区`)是`垃圾回收`的主要对象，特别是`Java堆`。

实际上，`Java`技术体系中所提倡的`自动内存管理`最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存，且这两个问题针对的内存区域就是`Java`内存模型中的`堆`区。

本文阐述了其三个核心问题，包括：

- 哪些内存需要回收？（对象是否可以被回收的两种经典算法：`引用计数法`和`可达性分析算法`）

- 什么时候回收？（堆的新生代、老年代、永久代的垃圾回收时机，`MinorGC`和`FullGC`）

- 如何回收？（三种经典垃圾回收算法（`标记清除算法`、`复制算法`、`标记整理算法`）及`分代收集算法`和`七种垃圾收集器`）

我们先记住一个词：`Stop-the-World`。

`Stop-the-world`意味着`JVM`由于要执行`GC`而停止了应用程序的执行，并且这种情形会在任何一种`GC`算法中发生。
当`Stop-the-world`发生时，除了`GC`所需的线程以外，所有线程都处于等待状态直到`GC`任务完成。
事实上，`GC`优化很多时候就是指减少`Stop-the-world`发生的时间，从而使系统具有`高吞吐`、`低停顿`的特点。

- 内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，
  `Java`的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为`对象游离`。

----
