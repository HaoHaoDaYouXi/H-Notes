## Java 基础

### JVM
Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，
Linux，macOS），⽬的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的
JVM 实现是 Java 语⾔“一次编译，随处可以运行”的关键所在。
JVM 并不是只有一种！只要满⾜ JVM 规范，每个公司、组织或者个⼈都可以开发⾃⼰的专属
JVM。 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。
除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。维基百科上
就有常⻅ JVM 的对比：Comparison of Java virtual machines ，感兴趣的可以去看看。并且，你可
以在 Java SE Specifications 上找到各个版本的 JDK 对应的 JVM 规范。

### JDK 和 JRE

JDK 是 Java Development Kit 缩写，它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的一切，还有
编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。
JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机
（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。
如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些
Java 编程方面的⼯作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计
算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么
从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序
服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。

## <a id="java_ts">java的特色</a>
1. 简单易学、有丰富的类库
2. 面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高）
3. 与平台无关性（JVM是Java跨平台使用的根本）
4. 可靠安全
5. 支持多线程

## <a id="java_dt">java的多态、泛型、反射、注解、序列化</a>

### 多态
> 多态，顾名思义，表示一个对象具有多种的状态，具体表现为⽗类的引用指向⼦类的实例。

- 多态的特点:
  - 对象类型和引用类型之间具有继承（类）/实现（接⼝）的关系；
  - 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；
  - 多态不能调用“只在⼦类存在但在⽗类不存在”的方法；
  - 如果⼦类重写了⽗类的方法，真正执行的是⼦类覆盖的方法，如果⼦类没有覆盖⽗类的方法，执 行的是⽗类的方法。

### 泛型
> 顾名思义，“泛指的类型”。

我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，比如我们用的非常多的`ArrayList`就是个泛型类，`ArrayList`作为集合可以存放各种元素，
如`Integer`,`String`，自定义的各种类型等，但在我们使用的时候通过具体的规则来约束，
如我们可以约束集合中只存放`Integer`类型的元素，如
~~~
List<Integer> iniData = new ArrayList<>()
~~~

#### 类型通配符

类型通配符一般是使用`?`代替具体的类型参数。例如`List<?>`在逻辑上是`List<String>`,`List<Integer>`等所有`List<具体类型实参>`的父类。

#### 类型擦除

Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛型中的类型信息的。
使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。
如在代码中定义的`List<Object>`和`List<String>`等类型，在编译之后都会变成 List。
JVM 看到的只是`List`，而由泛型附加的类型信息对 JVM 来说是不可见的。
类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是`Object`。
如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。

#### 使用泛型的好处？

以集合来举例，使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合，如整
型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型
数据，而这并不是最重要的，因为我们只要把底层存储设置了`Object`即可，添加的数据全部都可向
上转型为`Object`。 更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。

### 反射
> 在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；
并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方
法的功能成为 Java 语言的反射机制。

#### 反射的优缺点？
反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。
不过，反射让我们在运行时有了分析操作类的能⼒的同时，也增加了安全问题，
比如可以⽆视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。
另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不⼤的。

#### 哪里会用到反射机制？
jdbc就是典型的反射
~~~
Class.forName('com.mysql.jdbc.Driver.class');//加载MySQL的驱动类
~~~

#### 反射`API`
反射`API`用来生成 JVM 中的类、接口或则对象的信息
1. `Class`类：反射的核心类，可以获取类的属性，方法等信息。
2. `Field`类：`Java.lang.reflec`包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。
3. `Method`类：`Java.lang.reflec`包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。
4. `Constructor`类：`Java.lang.reflec`包中的类，表示类的构造方法。

#### 反射使用步骤
1. 获取想要操作的类的`Class`对象，他是反射的核心，通过`Class`对象我们可以任意调用类的方法。
2. 调用`Class`类中的方法，既就是反射的使用阶段。
3. 使用反射`API`来操作这些信息。

### 注解
> `Annotation`（注解）是 Java 提供的一种对元程序中元素关联信息和元数据（metadata）的途径和方法。
> `Annatation`(注解)是一个接口，程序可以通过反射来获取指定程序中元素的`Annotation`对象，
> 然后通过该`Annotation`对象来获取注解中的元数据信息。

#### 4 种标准元注解

元注解的作用是负责注解其他注解。 Java5.0 定义了 4 个标准的 meta-annotation 类型，它们被
用来提供对其它 `annotation` 类型作说明。

#### `@Target` 修饰的对象范围

`@Target`说明了`Annotation`所修饰的对象范围：`Annotation`可被用于`packages`、`types`（类、
接口、枚举、`Annotation`类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数
和本地变量（如循环变量、`catch` 参数）。在`Annotation`类型的声明中使用了`target`可更加明晰
其修饰的目标

#### `@Retention` 定义 被保留的时间长短

`@Retention`定义了该`Annotation`被保留的时间长短：表示需要在什么级别保存注解信息，用于描
述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）由：
- `SOURCE`：在源文件中有效（即源文件保留）
- `CLASS`：在`class`文件中有效（即`class`保留）
- `RUNTIME`：在运行时有效（即运行时保留）

#### `@Documented` 描述-javadoc

`@Documented` 用于描述其它类型的`annotation`应该被作为被标注的程序成员的公共`API`，因此可以被例如`javadoc`此类的工具文档化。

#### `@Inherited` 阐述了某个被标注的类型是被继承的

`@Inherited` 元注解是一个标记注解，`@Inherited` 阐述了某个被标注的类型是被继承的。
如果一个使用了`@Inherited`修饰的`annotation`类型被用于一个`class`，则这个`annotation`将被用于该`class`的子类。

### 序列化

如果我们需要持久化`Java`对象比如将`Java`对象保存在文件中，或者在网络传输`Java`对象，这些场景都需要用到序列化。

简单来说：
- 序列化： 将数据结构或对象转换成⼆进制字节流的过程
- 反序列化：将在序列化过程中所生成的⼆进制字节流转换成数据结构或者对象的过程

对于`Java`这种面向对象编程语⾔来说，我们序列化的都是对象`Object`也就是实例化后的类`Class`，但是在 C++这种半面向对象的语⾔中，struct(结构体)定义的是数据结构类型，而`class`对应的是对象类型。

`Serializable`实现序列化
- 在 Java 中，只要一个类实现了`java.io.Serializable`接口，那么它就可以被序列化。

通过`ObjectOutputStream`和`ObjectInputStream`对对象进行序列化及反序列化。

在类中增加`writeObject`和`readObject`方法可以实现自定义序列化策略。

序列化`ID`
- 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化`ID`是否一致（就是`private static final long serialVersionUID`）

#### 对于不想进行序列化的变量，使用 transient 关键字修饰。

`Transient`关键字阻止该变量被序列化到文件中
1. 在变量声明前加上 Transient 关键字，可以阻止该变量被序列化到文件中，在被反序列
   化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。
2. 服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串
   等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在
   客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的
   数据安全。
