# Redis 持久化
持久化这个东西，我们要从它是什么，为什么要用它以及它都有哪些用法
和这些用法的区别来决定使用场景，这些方方面面来看待

Redis提供了多种级别的持久化方式：

    RDB持久化可以在指定时间间隔生成数据的时间快照(point-in-time snapshot)。
	AOF持久化记录服务器所有的写操作命令，并在服务器启动时，
	通过重新执行这些命令来还原数据，
	AOF文件中的命令全部以Redis协议的格式保存，新命令追加到文件的末尾，
	Redis还可以在后台对AOF文件重写，保证AOF文件大小不超过保存数据状态的实际大小	



## RDB
RDB触发可以分两种手动触发和自动触发，手动触发对应save和bgsave命令，save阻塞当前redis服务器，知道RDB完成，
对内存大的实例会造成长时间的阻塞，线上不建议使用，bgsave：Redis进程执行fork操作创建子线程，由子线程负责，完成后
自动结束，阻塞只会在fork时，一般很短，自动触发通过配置save，如 "save m n"，表示m秒内数据集存在n次修改时，自动触发bgsave,
节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点，执行debug reload命令重新加载redis时，也会
自动触发save操作，默认情况下执行shutdown命令时，如果没有开启AOF持久化则自动执行bgsave，bgsave是RDB主流的持久化方式，
执行bgsave命令时，Redis父进程判断是否存在正在执行的RDB\AOF子进程，有就直接返回，没有就fork操作创建一个子线程，fork
过程中父进程会阻塞，通过"info stats"可以查看latest_fork_usec选项，可以返回一个最近fork操作的耗时，单位微秒，fork完后，
bgsave返回"background saving started" 不在阻塞父进程，可以继续其他命令，子线程创建RDB文件，根据父进程内存生成临时
快照文件，完成后对原有文件进行原子替换，通过lastsave命令可以查看最后一次生成RDB时间，子线程完成后告诉父线程，
父线程更新信息，RDB文件保存在dir配置指定的目录下
	
RDB优点，它是一个二进制的文件，代表Redis在某个时间节点上的数据快照，非常适合备份，全量复制，比如每6小时
执行bgsave备份，并把RDB文件拷贝到远程机器或文件系统，用于灾难恢复，redis加载RDB恢复数据远远快于AOF方式，缺点是
没办法做到实时/秒级持久化，因为每次bgsave都要执行fork创建子线程，属于重量级操作，频繁操作成本太高，RDB文件使用特定的
二进制保存，redis老版本无法兼容新版本




## AOF
开启AOF需要设置配置：appendonly yes，默认不开启，AOF文件保存路径也是通过dir配置，AOF流程是：
命令写入(append)、文件同步(sync)、文件重写(rewrite)、重启加载(load)，AOF所有的写入命令会追加到aof_buf(缓冲区)，redis
使用单线程响应命令，如果每次写AOF文件命令都追加到硬盘，那性能全部取决于硬盘的负债，redis可以提供多种缓冲区同步硬盘
的策略，在性能和安全做出平衡，根据AOF的文件越来越大，需要定期重写AOF文件，达到压缩，重写就是把已经超时的数据不在写入
，还有各种数据定义和改变过程，只保留最终的值，多个写入的命令也可以合并一个，重写不止减少空间，也是为了redis更快的重载
，重写过程可以手动触发和自动触发，手动触发直接调用bgrewriteaof命令，自动触发根据设置的参数(auto-aof-rewrite-min-size 
最小大小 默认64M，auto-aof-rewrite-percentage 当前文件空间(aof_current_size)和上次重写AOF文件空间(aof_base_size)的比值)
自动触发机制：当前文件大小大于最小体积 && (当前大小-上次重写大小) / 上次重写大小 >= 规定的比值
	
redis重启时，若开启AOF持久化并存在AOF文件，优先加载AOF文件，AOF关闭或文件不存在，加载RDB，加载文件
成功后，redis启动成功，文件存在错误，启动失败并打印错误信息
